# 3. transport layer1

## 1. Transport Layer 서비스 및 개요

---

### 1. Transport Layer

transport layer protocol은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신`(logical communication)` 을 제공 
⇒ 애플리케이션 관점, 프로세스들이 동작하는 호스트들이 직접 연결된 것 처럼 보임

- transport layer protocol은 네트워크 라우터가 아닌 **종단 시스템**에서 구현된다
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/5cc0b978-48b0-4d58-88e0-5f83c1664056/Untitled.png)
    
    1. 송신 측의 transport layer은 송신 애플리케이션 프로세스로부터 수신한 메세지를 **transport layer 패킷**으로 변환
    (`L4-PDU` : 트랜스포트 계층 세그먼트)
    2. transport layer은 송신 종단 시스템에 있는 네트워크 계층으로 세그먼트를 전달
    (세그먼트는 네트워크 계층 패킷(`L3-PDU` : 데이터그램) 안에 캡슐화되어 목적지로 전달)
    3. 수신 측에서 네트워크 계층은 데이터그램으로부터 transport layer 세그먼트를 추출하고 **transport layer으로 세그먼트를 보냄**
    4. transport layer은 수신 애플리케이션에서 세그먼트 내부의 데이터를 이용할 수 있도록 수신된 세그먼트를 처리
- 네트워크 애플리케이션에서는 하나 이상의 **transport layer 프로토콜**을 사용할 수 있음
ex) 인터넷 : TCP, UDP

### 2. transport layer와 network layer 사이의 관계

- `트랜스포트 계층 프로토콜` : 각기 다른 호스트에서 동작하는 **프로세스들** 사이의 논리적 통신을 제공
    - 종단 시스템에 존재
    - 애플리케이션 프로세스에서 네트워크 계층 사이에서 메시지를 운반하는 역할
- `네트워크 계층 프로토콜` : **호스트들** 사이의 논리적 통신을 제공
1. 트랜스포트 계층이 제공할 수 있는 서비스는 **하위 네트워크 계층 프로토콜의 서비스 모델에 의해 제약받는다.**
    
    → 네트워크 계층 프로토콜이 호스트 사이에서 전송되는 트랜스포트 계층 세그먼트에 대한 **지연 보장이나 대역폭 보장**을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메시지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다.
    
2. 하위 네트워크 프로토콜이 상응하는 서비스를 제공하지 못할 때도, 특정 서비스는 트랜스포트 프로토콜에 의해 제공될 수 있다.
    
    → 하위 네트워크 프로토콜이 비신뢰적일 때, 트랜스포트 계층이 애플리케이션에게 신뢰적인 데이터 전송 서비스를 제공할 수 있다.
    (비신뢰적이다 = 패킷을 분실하거나, 손상시키거나, 복사본을 만든다)
    

### 인터넷 transport layer의 개요

- **TCP (Transmission Control Protocol)**
    - 신뢰적이고 연결지향형 서비스 제공
    - **혼잡 제어** (congestion control) : 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하도록 해줌
- **UDP (User Datagram Protocol)**
    - 비신뢰적이고 비연결형인 서비스 제공
    - UDP 트랜스포트 프로토콜을 사용하는 애플리케이션은 허용이 되는 한, 그것이 만족하는 어떤 속도로든 전송할 수 있
- **Segment 와 Datagram**
    - 세그먼트 : 트랜스포트 계층 패킷을 일컫는 말
    - TCP에 대한 패킷 : segment
    - UDP에 대한 패킷 : datagram
    

## 2. 다중화와 역다중화

---

네트워크 계층이 제공하는 `host 대 host` 전달 서비스에서 호스트에서 동작하는 애플리케이션에 대한 `process 대 process` 전달 서비스로 확장하는 과정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/7cccdb77-5bac-4090-a207-192cfadb6b85/Untitled.png)

1. 목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로 부터 `세그먼트`를 수신
    
    → 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 **세그먼트의 데이터를 전달하는 의무**를 가진다
    
2. 트랜스포트 계층은 세그먼트(데이터)를 중간 매개자린 `소켓`에게 전달
    - 프로세스는 네트워크 애플리케이션의 한 부분으로서 소켓을 가지고 있음 
    → 소켓 : 한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할, `포트 번호` 존재

**역다중화 (demultiplexing)
:** 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업

1. 호스트의 각 소켓은 포트 번호를 할당받는다.
2. 세그먼트가 호스트에 도착하면,
    1. 트랜스포트 계층은 세그먼트 안의 **목적지 포트 번호를 검사**하고,
    2. 그에 상응하는 소켓으로 세그먼트를 보낸다.
3. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다.

**다중화 (multiplexing)**

1. 출발지 호스트에서 소켓으로 부터 데이터를 모으고
2. 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보를 캡슐화
3. 그 세그먼트들을 네트워크 계층으로 전달

**다중화의 2가지 요구사항**

1. 소켓은 유일한 식별자를 갖는다 (포트 번호)
2. 각 세그먼트는 세그먼트가 **전달될 적절한 소켓을 가리키는 특별한 필드**를 갖는다
    - `출발지 포트 번호 필드(source port number field)`
    - `목적지 포트 번호 필드(destination port number field)`
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/1b591943-99d5-4b8b-bb2e-11109fc2427e/Untitled.png)
    

### 비연결형 다중화와 역다중화

UDP 소켓은 `목적지 IP 주소`와 `목적지 포트 번호`로 구성된 두 요소로 된 집합에 의해 식별된다.

→ ex) 2개의 UDP 세그먼트가 **같은 목적지 IP 주소와 목적지 포트 번호**를 가진다면, 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것

- **출발지 포트 번호**는 목적 : ‘회신 주소’의 한 부분으로 사용

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/90680eb4-d4f8-4c6f-ba12-cf43dd54ca9c/Untitled.png)

- B가 A에게로 세그먼트를 보내기를 원할 때
    
    : B에서 A로 가는 **세그먼트의 목적지 포트 번호는** A로부터 B로 가는 세그먼트의 **출발지 포트 번호로부터 가져온다.**
    

### 연결지향형 다중화와 역다중화

**TCP 소켓**은 4개 요소의 집합에 의해 식별

- 출발지 IP 주소
- 출발지 포트 번호
- 목적지 IP 주소
- 목적지 포트 번호

⇒ 다른 출발지 IP 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향한다.

**Persistent & Non-persistent HTTP**

- **지속적인(persistent) HTTP**
    
    지속적인 연결의 존속 기간에 클라이언트와 서버는 **같은 서버 소켓을 통해** HTTP 메시지를 교환
    
- **비지속적인(non-persistent) HTTP**
    
    모든 요청/응답마다 새로운 TCP 연결이 생성되고 종료
    

## 비연결형 트랜스포트 : UDP

---

UDP는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작

- 다중화/ 역다중화 기능
- 간단한 오류 검사 기능
- 비연결형 : 핸드세이크 하지 않는다
- DNS : 전형적으로 UDP를 사용하는 애플리케이션 계층 프로토콜
    
    질의 호스트가 응답을 수신하지 못하면 질의를 다른 네임 서버로 송신하거나, 애플리케이션에게 응답을 수신할 수 없음을 통보
    

### UDP 세그먼트 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/675bf9f7-7ca1-4ef3-804b-da192fbca7eb/Untitled.png)

**애플리케이션 데이터 :** UDP 데이터그램의 데이터 필드에 위치

**포트 번호 :** 목적지 호스트가 목적지 종단 시스템에서 동작하는 (역다중화 기능을 수행하는) 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해준다.

**체크섬(checksum) :** 세그먼트에 오류가 발생했는지 검사하기 위해 수신 호스트가 사용

- 과정
    1. 송신자 측에서 세그먼트 안에 있는 **모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행**하며,
        
        합산 과정에 발생하는 오버플로는 윤회식 자리올림(wrap around)을 한다.
        
    2. 이 결과값이 UDP 세그먼트의 체크섬 필드에 삽입된다.
    3. 수신자에서는 **체크섬을 포함한 모든 16비트 워드들이 더해진다.**
    4. 만약 패킷에 어떤 오류도 없다면 수신자에서의 합은 `1111111111111111`이 되며,
        
        비트 중에 `0이 하나라도 있다면` 패킷에 오류가 발생했다는 것이다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/9eaee283-8a85-4e50-ab35-816f2ca51bf1/Untitled.png)
        
- 체크섬 제공 이유 : 출발지와 목적지 사이의 모든 링크가 오류검사를 제공한다는 보장이 없기 때문

**길이 필드 :** 헤더를 포함하는 UDP 세그먼트의 길이를 바이트 단위로 나타냄

## 4. 신뢰적인 데이터 전송의 원리

---

`신뢰적인 데이터 전송`을 구현하는 문제는 transport layer뿐만 아니라 링크 계층에서도 발생할 수 있는 문제이다.

### 1. 신뢰적인 데이터 전송 연구의 프레임워크

- **서비스 모델**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/d4801536-2eaa-427c-84b7-6ca2b1c2872e/Untitled.png)

- **서비스 구현**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/7bd0790a-c2ed-48c3-83e0-fb496c51bba6/Untitled.png)

상위 계층 객체에게 제공되는 서비스 추상화는 / **데이터가 전송될 수 있는 신뢰적인 채널**의 서비스 추상화이다

- 신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않으며
- 모든 데이터는 전송된 순서 그대로 전달된다 
**(패킷은 순서대로 전달된다→ 하부 채널은 패킷의 순서를 바꾸지않음)**

⇒ TCP 가 인터넷 애플리케이션에게 제공하는 서비스 모델

- `신뢰적인 데이터 전송 프로토콜` 의 의무 : 신뢰적인 채널의 서비스 추상화를 구현하는 것

- **b : 데이터 전송 프로토콜의 인터페이스**
    - 데이터 전송 프로토콜의 송신 측은 `rdt_send()` 호출로 위쪽으로 부터 호출될 것이며, 수신 측에서는 상위 계층으로 전달될 데이터를 넘길 것이다.
        - `rdt` : 신뢰적인 데이터 전송(reliable data transfer) 프로토콜을 나타냄
        - `_send` : rdt의 송신 측이 호출되고 있음을 나타냄
    - 수신 측에서 `rdt_rcv()` 는 패킷이 채널의 수신 측으로 도착했을 때 호출된다.
    - rdt 프로토콜이 상위 계층에 데이터를 전달하려고 할 때 `deliver_data()` 를 호출한다.
    

### 2. 신뢰적인 데이터 전송 프로토콜의 구축

**유한상태 (finite-state machine, FSM)**

- 화살표 는 한 상태로부터 다른 상태러의 전이를 나타낸다
- FSM의 촉 상태는 점선 화살표로 표시된다.

### 3. rdt1.0 : 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송

**rdt1.0에 대한 FSM**

- a 는 sender. b 는 receiver
- rdt1.0에서 **각각의 FSM은 하나의 상태만을 가지므로**, 전이는 필연적으로 그 상태로부터 자신으로 되돌아 온다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/83090ed4-a0df-42de-ad0d-88b104f6dbd9/Untitled.png)
    

**Sender**

1. `rdt_send(data)` 이벤트에 의해 
→ 상위 계층 애플리케이션의 프로시저 호출(`rdt_send()` 에 의해 발생)
    1. 상위 계층으로부터 데이터를 받아들이고 
    2. 데이터를 포함한 패킷을 생성(`make_pkt(data)`)
2. 패깃을 채널로 송신한다.

**Receiver**

1. rdt는 `rdt_rcv(packet)` 이벤트에 의해 하위의 채널로부터 패킷을 수신한다.
→ 하위 계층 프로토콜로 부터의 프로시저 호출(`rdt_rcv()`)에 의해 발생
2. 패킷으로부터 데이터를 추출하고 (`extract(packet, data)`)
3. 데이터를 상위 계층으로 전달 (`deliver_data(data)`)

**Thus**

- 데이터 단위와 패킷의 차이점이 없으며, 모든 패킷 흐름은 송신자 → 수신자 까지
- **수신 측이 송신 측에게 어떤 피드백도 제공할 필요가 없음** ⇒ 완전히 신뢰적인 채널

### 4. rdt2.0 : 비트 오류가 있는 채널상에서의 신뢰적인 데이터 전송

패킷 안의 비트들이 하위 채널에서 손상되는 모델
→ 일반적으로 비트 오류는 패킷이 전파되거나 버퍼링될 때 네트워크의 물리적인 구성요소에서 발생

**자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜**

- 긍정 확인 응답 (positive acknowledgment, “OK”)
- 부정 확인 응답 (negative acknowledgment, “그것을 반복해 주세요”)
- 비트 오류 처리를 위한 3가지 부가 프로토콜 기능
    1. **오류 검출** : 수신자가 검출할 수 있는 기능 → checksum
    2. **수신자 피드백** : 송신자가 수신자의 상태를 알기 위한 유일한 방법, 패킷이 정확하게 수신되었는지 아닌지
    3. **재전송** : 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송

**rdt2.0에 대한 FSM**

- **Sender**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/e0d2dcab-d3db-4394-afdc-45ac520bb79f/Untitled.png)
    
    1. 왼쪽 상태
        
        송신 측 프로토콜은 상위 계층으로부터 **데이터가 전달되기를 기다린다.**
        rdt_send(data) 이벤트가 발생하면,
        
        1. 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷(sndpkt)을 생성하고
        2. 그 패킷을 udt_send(sndpkt) 동작을 통해 전송
    2. 오른쪽 상태
        
        송신자 프로토콜은 수신자로부터 **ACK 또는 NAK 패킷을 기다린다.**
        
        1. 만약 ACK 패킷이 수신된다면 (`rdt_rcv(rcvpkt) && isACK(rcvpkt)`)
            - 가장 최근에 전송된 패킷이 정확하게 수신되었음을 의미
            - 프로토콜은 상위 계층으로부터 데이터를 기다리는 상태로 돌아간다.
        2. 만약 NAK 가 수신된다면
            - 프로토콜은 마지막 패킷을 재전송한다.
            - 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK 또는 NAK를 기다린다.
    - `전송 후 대기(stop-and-wait) 프로토콜`
        
        송신자가 ACK 또는 NAK를 기다리는 상태에 있을 때, **상위 계층으로부터 더 이상의 데이터를 전달 받을 수 없다. ⇒** 송신자는 **수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지** 새로운 데이터를 전달하지 않는다.
        
    

- **Receiver**
    
    단일 상태를 갖는다
    
    패킷이 도착했을 때, 수신자는 수신된 패킷이 손상되었는지 아닌지에 따라 `ACK` 또는 `NAK`로 응답
    

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/c2743091-f7ac-48be-83c1-add13bc750a1/Untitled.png)

**rdt2.0의 결함**

`ACK 또는 NAK 패킷이 손상될 수 있다`는 가능성을 고려하지 않음 
⇒ 송신자는 수신자가 전송된 데이터의 마지막 부분을 올바르게 수신했는지 알 수 없다

- 해결책
    
    데이터 패킷에  새로운 필드를 추가하고 이 필드 안에 순서 번호(sequence number)를 삽입하는방식으로 데이터 패킷에 송신자가 번호를 붙인다
    
    → 수신자는 수신된 패킷이 재전송인지를 결정할 때는 이 순서 번호만 확인하면 된다.
    

### rdt2.1 : rdt2.0의 수정 버전

1. 프로토콜 상태가 현재 (송신자에 의해) 전송되고 있는지에 대한 반영
2. (수신자가) 기다리고 있는 패킷이 순서 번호 0 또는 1을 가져야 하는지에 대한 반영

수신자로 부터 송신자까지의 긍정 확인 응답과 부정확인 응답을 모두 포함

- **순서가 바뀐 패킷이 수신되면**, 수신자는 `이미 전에 수신한 패킷에 대한 긍정 확인 응답`을 전송한다
- **손상된 패킷이 수신**되면, 수신자는 `부정 확인응답`을 전송한다.

- **송신자**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/8e32fd40-3581-4fb1-a024-854ee8752cc6/Untitled.png)
    
- 수신자
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/89e31aa1-d34e-4232-8992-6813a30d95bc/Untitled.png)
    

### rdt2.2 : 비트 오류를 갖는 채널을 위한 NAK 없는 신뢰적인 데이터 전송 프로토콜

1. 수신자가 반드시 ACK 메시지에 의해 확인 응답되는 패킷의 순서 번호를 포함해야한다
    
    → 이는 수신자 FSM의 `make_pkt()` 에 `ACK, 0` 또는 `ACK, 1` 인 인수를 넣어서 수행한다
    
2. 송신자는 수신된 ACK 메시지에 의해 확인응답된 **패킷의 순서 번호를 반드시 검사**해야만 한다.
    
    → 이는송신자 FSM의 `isACK()`에 `0` 또는 `1`인 인수를 넣어서 수행한다.
    

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/40711037-9cec-4ba0-a2c9-452c77490963/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/f22a7a6c-4e8b-4a33-b9ed-7871cfaf13bb/Untitled.png)

### 5. rdt3.0 : 비트 오류와 손실이 있는 채널상에서의 신뢰적인 데이터 전송

**하위 채널이 패킷을 손실하는 경우**

1. 어떻게 패킷 손실을 검출할 것인지
2. 패킷 손실이 발생했을 때 어떤 행동을 할 것인지

- 송신자에게 손실된 패킷의 검출과 회복 책임을 부여
    
    송신자가 데이터 패킷을 전송하고, 패킷 또는 수신자의 패킷에 대한 ACK를 손실했다고 가정
    
    → 송신자는 데이터 패킷이 손실되었는지, ACK가 손실되었는지, 패킷 또는 ACK가 단순히 지나치게 지연된 것인지를 알지 못한다.
    
    **만약 송신자가 패킷을 잃어버렸다고 확신할 정도로 충분한 시간을 기다릴 수만 있다면,** 데이터 패킷은 간단하게 재전송될 수 있다.
    
    > 기다려야하는 시간
    송신자와 수신자 사이의 `왕복 시간 지연`(중간 라우터에서의 버퍼링을 포함) + 수신 측에서 `패킷을 처리하는 데 필요한 시간`
    > 
- 송신자 동작
    1. 매 패킷이 송신된 시간에 타이머를 시작한다
    2. 타이머 인터럽트에 반응한다
    3. 타이머를 멈춘다
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/97034251-7f82-4ccb-9531-ef7b87622ff5/Untitled.png)
    

**동작과 처리 과정**

프로토콜이 패킷 손실 또는 지연 없이 어떻게 동작하는지와 손실된 데이터 패킷을 어떻게 처리하는 지

프로토콜 rdt3.0은 `얼터네이팅 비트 프로토콜(alternating-bit protocol)`

**무손실 동작**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/ddab817d-8e70-4cc3-b35a-c0634066e7b0/Untitled.png)

**패킷 손실**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/2913f978-b491-4f4b-b712-56263eedf744/Untitled.png)

**ACK 손실**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/e88095f9-cffc-4c44-94c9-4f6ba4486554/Untitled.png)

**조급한 타임아웃**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/5541718c-29ed-4c63-bb1c-5f3dccb3ba3e/Untitled.png)

## 5. 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

> rdt3.0의 핵심적인 성능 문제는 전송 후 대기(stop-and-wait) 프로토콜이라는 점 때문에 발생한다.
> 

전송 후 대기 프로토콜은 형편없는 송신자 `이용률(utilization, 또는 효율)`을 갖는다.

해결책 : 송신자에게 확인응답을 기다리기 전에 송신을 전송하도록 허용하는 것 = `파이프라이닝`

⇒ window size 만큼 효율이 증가

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/0b8f66cb-eebf-4522-a4e4-39e52d80fdad/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/8afca45c-77ab-4f6b-8b26-12206123b925/Untitled.png)

**전송 후 대기 동작 → 3.0**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/a0d8b4f5-7252-433b-aaa3-38323aae9aff/Untitled.png)

**파이프라이닝 된 동작**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/a0ca48e3-cc6e-4bb6-b60c-bd552dcc2f7a/Untitled.png)

파이프라이닝 방식의 신뢰적인 데이터 전송 프로토콜에서의 중요성

1. **순서 번호의 범위가 커져야 한다**
    1. 각각의 전송 중인 패킷은 유일한 순서 번호를 가져야한다 
    → 전송 중인 확인응답(ACK)이 안된 패킷이 여럿 있을 수 있기 때문
2. **프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 한다.**
    1. 최소한 ‘송신자는 전송되었으나 확인응답되지 않은 패킷’을 버퍼링해야 한다.
    2. 정확하게 수신된 패킷의 버퍼링은 수신자에게서도 필요하다.
3. **필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려 있다.**

파이프라인  오류 회복의 두가지 기본적인 접근 방법

1. `GBN(Go-Back-N)` : N부터 반복
2. `SR(Selective Repeat)` : 선택적 반복

### GBN(Go-Back-N, N부터 반복) 프로토콜

송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송할 수 있다

그러나, 파이프라인에서 확인 응답이 안 된 패킷의 최대 허용 수 N보다 크지 말아야 한다

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/c9bce4be-a1c7-4a70-ab38-30e1c740b24d/Untitled.png)

- 확인응답이 안된 가장 오래된 패킷의 순서 번호를 `base`로 정의
- 가장 작은 순서 번호를 `nextseqnum`(전송될 다음 패킷의 순서 번호)으로 정의한다.
    1. 간격 `[0, base-1]` : 순서 번호는 이미 전송되고 확인응답이 된 패킷
    2. 간격 `[base, nextseqnum-1]` : 송신은 되었지만 아직 확인응답되지 않은 패킷
    3. 간격 `[nextseqnum, base+N-1]` : 상위 계층으로부터 데이터가 도착하면 바로 전송될 수 있는 패킷
    4. `base+N 이상`
        
        → 파이프라인에서 확인응답이 안 된 패킷(특히, 순서 번호 `base`를 가진 패킷)의 확인응답이 도착할 때까지 사용될 수 없다.
        

**슬라이딩 윈도 프로토콜(sliding-window protocol)**

전송되었지만 아직 확인응답이 안된 패킷을 위해, 허용할 수 있는 순서 번호의 범위는 순서 번호의 범위상에서 크기가 N인 `윈도(window)`로 나타낸다.

**패킷의 순서 번호 :** 실제로 패킷의 순서 번호는 패킷 헤더 안의 고정된 길이 필드에 포함된다.

- 만약 `k`가 패킷 순서 번호 필드의 비트 수라면, 순서 번호의 범위는 `[0, 2^k - 1]`
- 순서 번호의 제한된 범위에서, 순서 번호를 포함하는 모든 계산은 `모듈로(modulo) 2^k 연산`을 이용한다.

**ACK 기반의 NAK 없는 확장된(extended) FSM**

- **GBN 송신자**의 세 가지 타입의 이벤트 반응
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/265a6516-d028-4864-8d1a-318d13855033/Untitled.png)
    
    1. 상위로부터의 호출
        - `rdt_send()` 가 위로부터 호출되면, 송신자는 우선 윈도가 가득 찼는지 확인
            1. 윈도가 가득 차 있지 않다면 : 패킷이 생성되고 송신되며, 변수들이 적절하게 갱신
            2. 윈도가 가득 차 있다면 : 단지 데이터를 상위 계층으로 반환
                
                → 윈도가 가득 차 있지 않음을 가리키는 함축적인 의미, 상위 계층은 나중에 `rdt_send()`를 다시 시도 
                
    2. ACK의 수신
        
        순서 번호 n을 가진 패킷에 대한 확인응답은 `누적 확인응답(cumulative acknowledgment)` 으로 인식 → n 까지의 순서 번호를 가진 모든 패킷에 대한 확인 응답
        
    3. 타임아웃 이벤트
        
        타이머는 손실된 데이터 또는 손실된 확인응답 패킷으로부터 회복하는 데 사용
        
        타임아웃 발생 시, 송신자는 이전에 전송되었지만 아직 확인응답되지 않은 모든 패킷을 다시 전송
        
- 수신자
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/fa248385-dc8e-45f2-9ede-044ee155a3b9/Untitled.png)
    
    - 만약 순서 번호 n을 가진 패킷이 오류 없이, 순서대로 수신되면
    → 수신자는 패킷 n에 대한 ACK를 송신하고 상위 계층에 패킷의 데이터 부분을 전달
    - 그 외의 경우, 수신자는 그 패킷을 버리고 가장 최근에 제대로 수신된 순서의 패킷에 대한 `ACK를 재전송` 한다
    
    **GBM 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다.**
    
    지금 패킷 `n`이 수신되어야 하지만, 그 사람 다음의 패킷 `n+1`이 먼저 도착했다고 가정
    
    *(수신자는 상위 계층에 데이터를 전달해야 한다.)*
    
    데이터가 순서대로 전달되어야 하므로, 수신자는 패킷 `n+1`을 저장하고
    
    **나중에 패킷** `n`**이 수신되고 전달된 후에 상위 계층에 이 패킷을 전달한다.**
    
    그러나 만일 패킷 n이 손실된다면, GBN 재전송 규칙에 따라 수신자에게는 패킷 `n`과 `n+1`이 **모두 재전송**될 것이다.
    
    **이점** : 수신자 버퍼링이 간단하다 
    (수신자는 어떤 순서가 잘못된 패킷에 대해 버퍼링을 할 필요가 없다)
    
    - **송신자**가 유지해야 하는 것
        1. 윈도 상위와 하위 경계
        2. 이 윈도 안에 있는 nextseqnum 위치
    - **수신자**가 유지해야 하는 것 : 다음 순서 패킷의 순서 번호
    
    **단점 :** 패킷의 재전송이 손실되거나 왜곡될 수 있으므로 **많은 재전송이 필요할 수도 있음**
    

**윈도 크키가 4 패킷인 경우**

- **송신자는 패킷 0 ~ 3 까지 송신**
- 송신을 계속하기 전에 **하나 이상의 패킷이 긍정 확인응답되는 것을 기다려야 함**

- `ACK0 , ACK1` 처러 각각의 성공적인 ACK가 수신되었을 때
    1. 윈도는 앞으로 이동
    2. 송신자는 하나의 새로운 패킷(`pkt4와 pkt5`, 각각)을 전송
- 수신 측에서는 `pkt2` 가 손실되었으므로 `pkt3, 4, 5`는 **순서가 잘못된 패킷으로 발견되어 제거됨**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/2bda565a-df6a-4cf9-a122-8aa0d9af0672/Untitled.png)

**GBN 프로토콜의 성능 문제**

- 송신자가 패킷으로 파이프라인을 채우는 것을 통해 전송 후 대기 프로토콜에서의 채널 이용률 문제를 피하도록 함
- 그러나, 원도 크기와 대역폭 지연 곱의 결과가 모두 클 때, 많은 패킷이 파이프라인에 있을 수 있음 → GBN은 패킷 하나의 오류 때문에 많은 패킷을 재전송하므로, **많은 패킷을 재전송하는 경우 발생**

### SR(Selective Repeat, 선택적 반복) 프로토콜

수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 재전송

- 불필요한 재전송을 피한다
- 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 **개별적인 확인 응답**을 요구

`윈도 크키 N` : 파이프라인에서 아직 확인응답이 안 된 패킷 수를 제한하는 데 사용

**순서 번호 공간에 대한 SR 송신자의 관점**

- SR 수신자는 패킷의 순서와는 무관하게 `손상 없이 수신된 패킷`**에 대한 확인응답**을 할 것이다.
- `빠진 패킷`이 존재하는 경우
    1. 순서가 바뀐 패킷은 빠진 패킷이 수신될 때까지 버퍼에 저장
    (빠진 패킷 = 아직 도착하지 않은 더 낮은 순서 번호를 가진 패킷)
    2. 빠진 패킷이 수신된 시점에서 일련의 패킷을 순서대로 상위 계층에 전달할 수 있다.
    (re-order & reassemble the packets → in-order delivery to upper layer)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c6780e7-3b42-4d8b-8cbd-27338bbc555b/476dbdb7-45dc-44d6-b9e6-58de10606f9a/Untitled.png)

**송신자 이벤트와 행동**

1. 상위로부터 데이터 수신 : SR 송신자는 패킷의 다음 순서 번호 검사
    - 순서 번호가 송신자 윈도 내에 있으면 데이터는 패킷으로 송신
    - 그렇지 않으면, GBN 처럼 버퍼에 나중에 전송하기 위해 되돌려진다
2. 타임아웃 : 손실된 패킷을 보호하기 위해 재사용
    
    → 타임아웃 시 오직 한 패킷만이 전송되기 때문에, **각 패킷은 자신의 논리 타이머가 있어야 함**
    
3. ACK 수신 : SR 송신자는 그 ACK가 윈도 내에 있다면 그 패킷을 수신된 것으로 표기
    - 만약 패킷 순서 번호가 `send_base`와 같다면, 윈도 베이스는 가장 작은 순서 번호를 가진 아직 확인응답되지 않은 패킷으로 옮겨진다.
    - 만약 윈도가 이동하고 **윈도 내의 순서 번호를 가진 미전송 패킷이 있다면**, 이 패킷들은 전송된다.

**수신자 이벤트와 행동**

1. `[rcv_base, rcv_base+N-1]` 내의 순서 번호를 가진 패킷이 손상 없이 수신된다.
    
    이 경우는 **수신된 패킷이 수신자의 윈도에 속하는 것**이며, `선택적 ACK 패킷`이 송신자에게 회신된다
    
    - 이 패킷이 이전에 수신되지 않았던 것이라면 :  버퍼에 저장
    - 이 패킷이 수신 윈도의 base와 같은 순서 번호를 가졌다면 
    :  이 패킷과 이전에 버퍼에 저장되어 연속적으로 번호를 가진(`rcv_base`로 시작하는) 패킷들은 상위 계층으로 전달된다.
2. `[rcv_base-N, rcv_base-1]` 내의 순서 번호를 가진 패킷이 수신된다.
    
    이 경우에는 이 패킷이 수신자가 이전에 확인응답한 것이라도 **ACK가 생성되어야 한다.**
    
3. 그 외의 경우, 패킷을 무시한다.

**SR 동작**

1. 처음에 `pkt3, 4, 5`를 버퍼에 저장
2. 마지막으로 **pkt2가 수신되었을 때** `pkt2`와 함께 상위 계층에 전달
