<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3️⃣ Network Layer</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="c5bbc937-2fcb-4b4e-b25f-859e883a68e2" class="page sans"><header><h1 class="page-title">3️⃣ Network Layer</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesMultipleSelect"><path d="M1.91602 4.83789C2.44238 4.83789 2.87305 4.40723 2.87305 3.87402C2.87305 3.34766 2.44238 2.91699 1.91602 2.91699C1.38281 2.91699 0.952148 3.34766 0.952148 3.87402C0.952148 4.40723 1.38281 4.83789 1.91602 4.83789ZM5.1084 4.52344H14.3984C14.7607 4.52344 15.0479 4.23633 15.0479 3.87402C15.0479 3.51172 14.7607 3.22461 14.3984 3.22461H5.1084C4.74609 3.22461 4.45898 3.51172 4.45898 3.87402C4.45898 4.23633 4.74609 4.52344 5.1084 4.52344ZM1.91602 9.03516C2.44238 9.03516 2.87305 8.60449 2.87305 8.07129C2.87305 7.54492 2.44238 7.11426 1.91602 7.11426C1.38281 7.11426 0.952148 7.54492 0.952148 8.07129C0.952148 8.60449 1.38281 9.03516 1.91602 9.03516ZM5.1084 8.7207H14.3984C14.7607 8.7207 15.0479 8.43359 15.0479 8.07129C15.0479 7.70898 14.7607 7.42188 14.3984 7.42188H5.1084C4.74609 7.42188 4.45898 7.70898 4.45898 8.07129C4.45898 8.43359 4.74609 8.7207 5.1084 8.7207ZM1.91602 13.2324C2.44238 13.2324 2.87305 12.8018 2.87305 12.2686C2.87305 11.7422 2.44238 11.3115 1.91602 11.3115C1.38281 11.3115 0.952148 11.7422 0.952148 12.2686C0.952148 12.8018 1.38281 13.2324 1.91602 13.2324ZM5.1084 12.918H14.3984C14.7607 12.918 15.0479 12.6309 15.0479 12.2686C15.0479 11.9062 14.7607 11.6191 14.3984 11.6191H5.1084C4.74609 11.6191 4.45898 11.9062 4.45898 12.2686C4.45898 12.6309 4.74609 12.918 5.1084 12.918Z"></path></svg></span>태그</th><td><span class="selected-value select-value-color-brown">8주차</span><span class="selected-value select-value-color-green">CSS</span></td></tr></tbody></table></header><div class="page-body"><h1 id="d077b3cc-c19b-4bab-a669-da55e6bb7b81" class="">3.1 트랜스포트 계층 서비스 및 개요</h1><p id="bdaa1e81-20e8-4f99-b0e1-9cb6814d8898" class="">multiplexing: 하나로 섞는 것</p><p id="2317b447-9356-4768-bd00-bfb61bfe932f" class="">demultiplexing: 여러 개로 나뉘는 것 </p><h2 id="3693eb3a-1f97-4a87-9e72-d4d8e9cbda7f" class="">Transport services and protocols</h2><ul id="5a38c2c9-f14c-4cb7-b80e-0d005d07f275" class="bulleted-list"><li style="list-style-type:disc">transport layer: process 간의 <code>logical communication</code> 제공  </li></ul><ul id="cd3d951f-0a58-46cc-981e-5e61522ec17f" class="bulleted-list"><li style="list-style-type:disc"><code>logical communication</code> : 애플리케이션의 관점에서 봤을 때 프로세스들이 호스트에 직접 연결된 것처럼 보이는 것을 의미 </li></ul><ul id="e7f9021e-cfb3-40ed-b3fd-8f56ba23f7a8" class="bulleted-list"><li style="list-style-type:disc"><code>segment</code> : 트랜스포트 계층 패킷<ul id="75d313a8-fd41-4e25-a2a5-f09e4a0a0f3f" class="bulleted-list"><li style="list-style-type:circle">sender: 애플리케이션에서 socket을 통해 transport layer로 내려오면 그 메시지를 segment로 나눠서 network layer로 내려보냄</li></ul><ul id="29672fab-ac0e-437e-9aa9-78cbcc9826dc" class="bulleted-list"><li style="list-style-type:circle">receiver: 반대 </li></ul></li></ul><h2 id="74584b71-ab00-412c-81a3-534ad0a3fbce" class="">Transport vs Network layer</h2><ul id="ce09dcb9-98ed-4c5f-929a-a7ef0231d152" class="bulleted-list"><li style="list-style-type:disc">트랜스포트 계층은 프로토콜 스택에서 네트워크 계층 바로 상위에 존재한다.<ul id="fa377111-e4fe-4848-98eb-f842b12ea730" class="bulleted-list"><li style="list-style-type:circle">트랜스포트 계층: 다른 호스트에서 동작하는 프로세스들 사이의 논리적 통신 제공</li></ul><ul id="822aad9e-ebbb-4f8f-9eda-38c04db011c2" class="bulleted-list"><li style="list-style-type:circle">네트워크 계층: 호스트들 사이의 논리적 통신 제공 </li></ul></li></ul><ul id="1391efde-58a4-40ae-b89c-e4d87f184e6e" class="bulleted-list"><li style="list-style-type:disc">예시<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="51d02c30-0198-4b26-a98c-fdd757f463c7" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">애플리케이션 메시지 = 봉투 안의 편지
프로세스 = 사촌 형제
호스트(종단 시스템) = 집
트랜스포트 계층 프로토콜 = &#x27;앤&#x27;과 &#x27;빌&#x27; -&gt; 집 안에서 우편함(네트워크 경계)까지만 운반, 논리적 통신 제공
네트워크 계층 프로토콜 = 집배원 포함한 우편 서비스</code></pre></li></ul><h2 id="db56fe8f-458c-4256-a6e4-392e3f19a59a" class="">Internet transport-layer protocols</h2><ul id="4b44ce2c-ffb7-411c-b8e6-42e10b3b90b5" class="bulleted-list"><li style="list-style-type:disc">IP: 인터넷 네트워크 계층 프로토콜 <ul id="de1f0b1c-0928-4323-9989-9b902f8387c8" class="bulleted-list"><li style="list-style-type:circle">best-effort delivery service: 호스트 간 논리적 통신 제공, 어떠한 보장도 하지 않음(순서, 무결성) </li></ul><ul id="8b760994-5f9d-45e7-b661-e67db4c5eef7" class="bulleted-list"><li style="list-style-type:circle">unreliable </li></ul></li></ul><ul id="04701c8f-4889-47f9-9d5d-d4c8f58b63ca" class="bulleted-list"><li style="list-style-type:disc">UDP: unreliable, unordered delivery, best-effort  <ul id="ce3e9251-ef45-4118-8903-6f542f5569fd" class="bulleted-list"><li style="list-style-type:circle">세그먼트 or 데이터그램 </li></ul></li></ul><ul id="c278fd16-ec0e-489c-b84a-e1ba403ad9af" class="bulleted-list"><li style="list-style-type:disc">TCP: reliable, in-order delivery<ul id="7012a0c0-cffe-45f9-913b-f6e353cb34d4" class="bulleted-list"><li style="list-style-type:circle">세그먼트</li></ul></li></ul><h1 id="10d1c67e-bca2-4188-9cb7-63bf2dcc732f" class="">3.2 다중화와 역다중화</h1><ul id="7b11b789-9ea4-4adf-a4e2-8739821235e6" class="bulleted-list"><li style="list-style-type:disc">종단 시스템 사이의 IP 전달 서비스(호스트-호스트)를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스(프로세스-프로세스)로 확장하는 것</li></ul><ul id="6b2b3ac6-b4af-4e49-a36b-be7b7ed3c3c1" class="bulleted-list"><li style="list-style-type:disc">목적지 호스트에서 트랜스포트 계층은 아래 네트워크 계층으로부터 세그먼트를 수신<ul id="f0add26e-f98d-4a22-8ab1-cd0ec35101bf" class="bulleted-list"><li style="list-style-type:circle">트랜스포트 계층의 의무: 호스트에서 동작하는 해당 애플리케이션 프로세스에게 전달 </li></ul></li></ul><ul id="c5894ddf-59c4-4c71-a8ac-191db041990d" class="bulleted-list"><li style="list-style-type:disc">트랜스포트 계층은 세그먼트를 소켓에게 전달<ul id="f4e4a195-2410-4a35-af6c-89297f0e7629" class="bulleted-list"><li style="list-style-type:circle">소켓: 중간 전달자, 프로세스가 가지고 있음, 유일한 식별자(포트 번호)를 가짐</li></ul><ul id="ddff0be3-19f2-4fef-9cf7-3b20db554a5e" class="bulleted-list"><li style="list-style-type:circle">세그먼트: 필드 집합으로 식별한 후 소켓으로 보내짐(트랜스포트 계층) </li></ul></li></ul><h2 id="76792221-47a2-4f7f-bed3-a84090f28a81" class="">트랜스포트 계층이 네트워크 계층으로부터 데이터를 수신할 때 프로세스에게 수신한 데이터를 어떻게 전달하는지</h2><ul id="2ee51d9a-e275-4630-8853-b395cfae46f1" class="bulleted-list"><li style="list-style-type:disc">소켓: 프로세스가 가지고 있는 것<ul id="d28d9645-9558-4c93-8443-13c6df7d6b20" class="bulleted-list"><li style="list-style-type:circle">네트워크 ↔ 프로세스 데이터 전달(출입구 역할, 중간 매개자)</li></ul><ul id="f6d47689-f2e3-44e3-8f2f-2b63618efdb1" class="bulleted-list"><li style="list-style-type:circle">하나의 유일한 식별자를 가지고 있음(UDP, TCP에 따라 포맷 달라짐)</li></ul></li></ul><h3 id="14ef39a7-373d-4804-a6c3-d11fbd3fdc81" class="">역다중화</h3><ul id="f120208c-17f8-4404-b71e-43e53ee73ab8" class="bulleted-list"><li style="list-style-type:disc">트랜스포트 계층 세그먼트의 데이터를 소켓으로 전달하는 작업</li></ul><ul id="db2bc1eb-2b66-4476-8883-66cbd45f1057" class="bulleted-list"><li style="list-style-type:disc">세그먼트 필드 검사 후 소켓으로 보냄</li></ul><ul id="2803d0fe-5b6d-4a6f-9f6e-9ab5b4246bdf" class="bulleted-list"><li style="list-style-type:disc">하나 → 여러 개</li></ul><h3 id="b0b98eeb-0a09-40f5-91a9-0eeda77cb7df" class="">다중화</h3><ul id="617583fe-26e4-455d-abb3-a0e5da66c879" class="bulleted-list"><li style="list-style-type:disc">출발지 호스트에서 소켓으로부터 데이터를 모아서 생성한 세그먼트들을 네트워크 계층으로 전달하는 작업</li></ul><ul id="775cace3-97a7-42ad-9039-f6ccdef170fd" class="bulleted-list"><li style="list-style-type:disc">여러 개 → 하나</li></ul><h3 id="13367c92-2cb1-45db-92fd-72fdc0456d4d" class="">트랜스포트 계층 다중화의 두 가지 요구사항</h3><ol type="1" id="22e53fab-c478-4718-a0a4-ff709c396060" class="numbered-list" start="1"><li>소켓의 유일한 식별자</li></ol><ol type="1" id="df2eede9-a8a5-45af-ac55-05e9841cd7db" class="numbered-list" start="2"><li>세그먼트의 출발지 포트 번호 필드와 목적지 포트 번호 필드</li></ol><figure id="1132c7e3-4de4-40ed-b191-fea0dbc11b87"><div class="source"><a href="https://www.notion.soundefined"></a></div></figure><h2 id="ea581bb4-fc8e-40cb-8728-0a94cdd93571" class="">역다중화 서비스 순서</h2><ol type="1" id="82a2cc30-cbd5-4c6d-9c8f-cda229bbbe87" class="numbered-list" start="1"><li>호스트의 각 소켓은 포트 번호를 할당받는다.</li></ol><ol type="1" id="1704eada-b834-4ff5-a0be-948c6bb45caf" class="numbered-list" start="2"><li>세그먼트가 호스트에 도착하면, 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하고 상응하는 소켓으로 세그먼트를 보낸다.</li></ol><ol type="1" id="457b8ad0-4388-4893-944a-28ed6f08dd04" class="numbered-list" start="3"><li>세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다</li></ol><p id="2deb0b1f-8c63-41bf-bc41-f7699cf53690" class="">→ UDP의 기본 동작 방식</p><h2 id="7be7e0af-b2c3-4330-ad9f-67701915ad2d" class="">비연결형 다중화와 역다중화 </h2><ul id="c741086c-3f3a-4c8b-b386-678193ebaf04" class="bulleted-list"><li style="list-style-type:disc"><code>목적지 IP 주소</code>와 <code>목적지 포트 번호</code>에 의해 UDP 소켓이 식별</li></ul><ul id="bcded326-e272-44c6-bbd5-6ca9be0b44ff" class="bulleted-list"><li style="list-style-type:disc">출발지 포트 번호는 회신 주소의 부분으로 사용됨(받은 곳으로 답해야 할 때)</li></ul><h2 id="b4a7a658-36dd-4d86-82e7-3a2e7560d7e3" class="">연결지향형 다중화와 역다중화</h2><ul id="6abf3818-21b2-4b49-98a9-572bfa3ebdaa" class="bulleted-list"><li style="list-style-type:disc">TCP 소켓은 <code>출발지 IP 주소</code>, <code>출발지 포트 번호</code>, <code>목적지 IP 주소</code>, <code>목적지 포트 번호</code>로 식별됨</li></ul><h3 id="efa85a1a-46b1-4e67-80a6-d19d5bbe44f4" class="">TCP 연결 설정</h3><ul id="e501606a-d8f2-4cdb-a8d8-1a37e9ae734d" class="bulleted-list"><li style="list-style-type:disc"><code>출발지 IP 주소</code>, <code>출발지 포트 번호</code>, <code>목적지 IP 주소</code>, <code>목적지 포트 번호</code>에 의해 식별</li></ul><ol type="1" id="85057561-f6f0-4677-891b-a36394c57426" class="numbered-list" start="1"><li>‘환영 소켓’은 포트 번호 12000을 가진 TCP 클라이언트로부터 연결 설정 요청을 기다림</li></ol><ol type="1" id="9235dd7a-359f-4443-ae2c-fa1fd244efa7" class="numbered-list" start="2"><li>TCP 클라이언트는 소켓을 생성하고, 연결 설정 요청 세그먼트를 보냄</li></ol><ol type="1" id="50460b31-9641-4070-9788-91850703e78c" class="numbered-list" start="3"><li>서버 프로세스로 동작하는 컴퓨터 호스트 OS가 목적지 포트 12000을 포함하는 연결 요청 세그먼트를 받으면, 이 세그먼트를 포트 번호 12000으로 연결 수락을 기다리는 서버 프로세스로 보냄</li></ol><ol type="1" id="5ef0559d-52d7-4acc-9571-c4b5fae64255" class="numbered-list" start="4"><li>그 다음 도착하는 세그먼트의 4가지 튜플 값이 전부 일치하면, 이 소켓으로 역다중화</li></ol><h1 id="d8c8c828-d1a5-40c9-ac85-115cef29986e" class="">3.3 비연결형 트랜스포트: UDP</h1><ul id="b878fbd4-11c5-4da9-97d6-941b6cc5e6b3" class="bulleted-list"><li style="list-style-type:disc">RFC 768에 정의된 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작<ul id="373792a0-e2ab-4542-9d7d-48af2f13fa03" class="bulleted-list"><li style="list-style-type:circle">다중화 &amp; 역다중화</li></ul><ul id="e1a2917c-6e7d-4da1-899d-7c6973d29b9a" class="bulleted-list"><li style="list-style-type:circle">간단한 오류 검사</li></ul></li></ul><h2 id="41a1b493-b36f-4065-a499-ea2cf54ce03c" class="">UDP 동작 순서</h2><ol type="1" id="1d3d2d86-6576-428a-8a79-738f79dc3171" class="numbered-list" start="1"><li>애플리케이션 프로세스로부터 메시지를 가져와 다중화/역다중화 서비스에 대한 출발지 포트 번호와 목적지 포트 번호 필드를 첨부하고 다른 두 필드 추가 후 최종 세그먼트를 네트워크 계층으로 넘겨 줌</li></ol><ol type="1" id="5f911968-83a8-4e02-9f57-5e2f2e9a6ce3" class="numbered-list" start="2"><li>네트워크 계층은 트랜스포트 계층 세그먼트를 IP 데이터그램으로 캡슐화하고, 세그먼트를 수신 호스트에게 전달한다.</li></ol><ol type="1" id="42885de0-0c81-411e-92ea-4546252f25c6" class="numbered-list" start="3"><li>세그먼트가 수신 호스트에 도착한다면, 목적지 포트 번호를 사용해 데이터를 해당하는 애플리케이션 프로세스로 전달한다.</li></ol><ul id="95e7c25b-69cd-47b3-8bc3-7ebe245a35b4" class="bulleted-list"><li style="list-style-type:disc">UDP는 세그먼트를 송신을 위해 핸드셰이크를 사용하지 않음 → 비연결형</li></ul><h2 id="caa4f288-56d8-44bb-941f-e413e168df0c" class="">사용</h2><ul id="7ddd0361-39e3-4ea5-8111-834539b85d53" class="bulleted-list"><li style="list-style-type:disc">DNS: 전형적인 UDP 사용 애플리케이션 계층 프로토콜의 예</li></ul><ul id="4e00217b-0b74-44d4-8a9a-3f3ae056261b" class="bulleted-list"><li style="list-style-type:disc">실시간 멀티미디어 애플리케이션</li></ul><h2 id="1772d39b-6263-4284-8a27-ed315b908a56" class="">UDP 장점</h2><ul id="38b0f43d-2b1a-4e8c-b1e7-33872b300fc6" class="bulleted-list"><li style="list-style-type:disc">연결 설정이 없다. (지연도 없다.)</li></ul><ul id="a7c2e034-7db2-47cf-8820-5842aa8773a7" class="bulleted-list"><li style="list-style-type:disc">연결 상태가 없어서 간단다.</li></ul><ul id="260ac730-437f-479b-8cbc-f4da9b575584" class="bulleted-list"><li style="list-style-type:disc">작은 헤더 사이즈(8바이트, TCP: 20바이트)</li></ul><ul id="d4493b57-8180-451c-bcf3-1b3edea7d6f5" class="bulleted-list"><li style="list-style-type:disc">UDP는 프로세스가 데이터를 UDP에 전달하자마자 데이터를 세그먼트를 만들고, 즉시 네트워크 계층으로 전달하는 것이 가능 (↔ TCP는 아님, 혼잡 제어 메커니즘 존재)</li></ul><h2 id="e3f95f48-64b3-4bea-b7f0-92a9eb48c108" class="">UDP 단점</h2><ul id="82e1d82b-7736-4a78-b4be-69e19fa0a873" class="bulleted-list"><li style="list-style-type:disc">혼잡 제어를 하지 않음<ul id="c47c0fd9-6b61-4a79-abc9-76e626c46449" class="bulleted-list"><li style="list-style-type:circle">네트워크가 꼭 필요한 작업을 할 수 없게 되는 폭주 상태에 빠지는 것을 막지 못 함</li></ul></li></ul><h3 id="e3a07f3a-a4d9-4e36-a2f6-98b9305d484f" class="">UDP를 사용한 신뢰적인 데이터 전송</h3><ul id="483ab880-8d30-4480-9d5d-d8ae026d0d80" class="bulleted-list"><li style="list-style-type:disc">UDP를 사용할 때도 신뢰적인 데이터 전송이 가능하다.</li></ul><ul id="e6df05cc-4fbc-43cd-b168-4320585a5c26" class="bulleted-list"><li style="list-style-type:disc">애플리케이션 자체에서 신뢰성을 제공한다면 가능</li></ul><ul id="09336858-9a67-4b66-b72f-1936dce61329" class="bulleted-list"><li style="list-style-type:disc">예: QUIC(Quic UDP Internet Connection) 프로토콜</li></ul><h2 id="4910e4f1-7d42-42d7-bf77-10cbf93cf3a6" class="">UDP 세그먼트 구조</h2><figure id="a061f4b3-c47d-41f2-9a66-d42e2c7a931a" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled.png"><img style="width:336px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled.png"/></a></figure><ul id="0b2c79f6-b166-429c-b9ad-c904ecdd965d" class="bulleted-list"><li style="list-style-type:disc">헤더: 2바이트씩 구성된 4개의 필드</li></ul><ul id="b59da425-d9af-408d-8423-35bdd4531d75" class="bulleted-list"><li style="list-style-type:disc">데이터 필드</li></ul><h2 id="fdf5491c-3480-4127-bfc0-54a614c8af72" class="">UDP checksum</h2><ul id="6d975eb9-ebce-4478-bfc6-ed539dfb1b95" class="bulleted-list"><li style="list-style-type:disc">goal: 출발지→ 목적지로 이동할 때 오류(변경사항 검사) 검출</li></ul><h3 id="fc6027e1-10d3-42c9-8658-5706490506fe" class="">방법</h3><ol type="1" id="4818a019-7abb-488d-bcdd-fce85cae908c" class="numbered-list" start="1"><li>송신자 측에서 세그먼트 안에 있는 모든 16비트 워드의 합산에 대해 1의 보수 수행<br/>오버플로는 윤회식 자리올림<br/></li></ol><ol type="1" id="c65f2a17-692f-4bec-8c55-0b0fa0ea6649" class="numbered-list" start="2"><li>결과값이 UDP 세그먼트의 checksum 필드로</li></ol><ol type="1" id="0e9185c8-7e59-4bec-af9c-9d02e20682ba" class="numbered-list" start="3"><li>수신자 측에서는 체크섬을 포함한 모든 16비트 워드들이 더해짐</li></ol><ol type="1" id="14f133db-5524-4e43-a8e7-b71caf3f9330" class="numbered-list" start="4"><li>패킷에 어떤 오류도 없다면 수신자에서 합은 1111111111111111<br/>비트 중 0이 있으면 오류 발생한 것<br/></li></ol><h3 id="13708f5b-d622-4353-a815-56ca0ed3597d" class="">체크섬 제공 이유</h3><ul id="3fe6a9e9-e076-4f3b-b2bb-17db51e8e5e8" class="bulleted-list"><li style="list-style-type:disc">출발지 ↔ 목적지에서 모든 링크가 오류 검사를 제공한다는 보장이 없기 때문</li></ul><ul id="1f71aabc-9a30-4943-a08f-5b96a4443a2b" class="bulleted-list"><li style="list-style-type:disc">UDP는 오류 회복은 하지 않음<ul id="0f890810-b98e-4f00-9026-9edd67edbc02" class="bulleted-list"><li style="list-style-type:circle">손상된 세그먼트 버리거나 경고와 함께 세그먼트를 애플리케이션으로 넘</li></ul></li></ul><h1 id="58fd36cd-0980-4fc3-8d1a-989140b31f09" class="">3.4 신뢰적인 데이터 전송의 원리 </h1><ul id="8992ace6-7521-4140-8f8f-69ad9783214b" class="bulleted-list"><li style="list-style-type:disc">신뢰적인 데이터 전송 연구의 프레임워크: 제공된 서비스와 서비스 구현 </li></ul><div id="d19e3b28-1b09-4b62-bd1e-ccce06c9f711" class="column-list"><div id="37f040ab-5324-4fc7-b26f-b5300d41d49c" style="width:50%" class="column"><figure id="84182136-4c42-4a5c-8396-db867cc040f8" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%201.png"><img style="width:422px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%201.png"/></a></figure></div><div id="1114c354-451d-41d4-a7c5-4411ddd8d751" style="width:50%" class="column"><figure id="276800dc-a156-4613-ab0c-528b64ef20b5" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%202.png"><img style="width:443px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%202.png"/></a></figure><p id="47460696-035f-4ff3-a110-29f9ea25f17c" class="">
</p></div></div><ul id="411bc3d9-aeac-4e79-a38f-8cbc459c601d" class="bulleted-list"><li style="list-style-type:disc">신뢰적인 채널에서는 데이터 손상 x, 순서 보장</li></ul><ul id="b48730b5-51d2-4d3b-80ff-e7cb10772b13" class="bulleted-list"><li style="list-style-type:disc">TCP가 인터넷 애플리케이션에게 제공하는 서비스 모델 </li></ul><ul id="316a9d26-2822-4819-bafa-9d05c8150f06" class="bulleted-list"><li style="list-style-type:disc">신뢰적인 데이터 전송 프로토콜의 의무는 신뢰적인 채널의 서비스 추상화를 구현하는 것!</li></ul><ul id="e6a57173-3ab2-4ee9-b4f7-1d395b2bc3d6" class="bulleted-list"><li style="list-style-type:disc">가정: 패킷은 순서대로 전달된다.</li></ul><h3 id="1ff2a5c3-eeef-4e04-978d-25564e174a99" class="">b. 데이터 전송 프로토콜의 인터페이스 </h3><ul id="85ed9674-3de2-4355-a027-632ce3975826" class="bulleted-list"><li style="list-style-type:disc">rdt: 신뢰적인 데이터 전송 프로토콜(reliable data transfer)</li></ul><ul id="6a749c06-fe35-45c4-a543-04b01e1cdb6a" class="bulleted-list"><li style="list-style-type:disc">_send: 송신 측 호출되고 있음을 나타냄 </li></ul><ul id="54e2778e-bc9a-4267-8ffd-33f0f6829605" class="bulleted-list"><li style="list-style-type:disc">rdt_rcv(): 패킷이 수신 측에 도착했을 때</li></ul><ul id="88dba9b3-f075-48c7-b194-3e7b04067de6" class="bulleted-list"><li style="list-style-type:disc">deliver_data(): rdt 프로토콜이 상위 계층으로 데이터를 전달하려고 할 때</li></ul><ul id="4969b394-6183-474d-aa4a-0989326e9b7b" class="bulleted-list"><li style="list-style-type:disc">단방향 데이터 전송은 송신→수신만 고려</li></ul><h2 id="0077012d-8dfb-43c7-98e0-a70985d27cea" class="">신뢰적인 데이터 전송 프로토콜의 구축</h2><h3 id="fc4d7b50-527d-4d4b-9552-11b1637e1192" class="">rdt1.0: 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송</h3><ul id="8d05f147-3c39-4e3f-99a1-23dc80b472b4" class="bulleted-list"><li style="list-style-type:disc">하위 채널이 완전히 신뢰적인 가장 간단한 경우 </li></ul><figure id="fb98ed92-e327-49d0-9d55-320c169d5829" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%203.png"><img style="width:527px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%203.png"/></a><figcaption>송신자와 수신자에 대한 분리된 FSM</figcaption></figure><blockquote id="60893a69-ca83-496d-b417-6052838c5519" class="">송신자</blockquote><ol type="1" id="f8cd61e0-8e6d-4691-a5bb-d3a3c3275163" class="numbered-list" start="1"><li>rdt_send(data): 상위 계층으로부터 data 받음</li></ol><ol type="1" id="80a392e7-579d-4346-9efc-0133e3c78593" class="numbered-list" start="2"><li>make_pkt(data): data를 포함한 패킷 생성</li></ol><ol type="1" id="71260421-edb3-48c0-829f-6428d2be7640" class="numbered-list" start="3"><li>udt_send(packet): 패킷을 채널로 송신</li></ol><blockquote id="48a4cd25-72e6-4fea-b778-d7c2f6f9970e" class="">수신자</blockquote><ol type="1" id="10b09b7a-0a49-4990-a14b-7138607ed1b0" class="numbered-list" start="1"><li>rdt_rcv(packet): 하위 채널로부터 패킷 수신</li></ol><ol type="1" id="0fa22dbd-3f6e-40da-a925-d76c11377322" class="numbered-list" start="2"><li>extract(packet, data): 패킷으로부터 데이터 추출</li></ol><ol type="1" id="67c6dcaa-9d0e-4a49-a330-7ef0d8c82a4c" class="numbered-list" start="3"><li>deliver_data(data): 상위 계층으로 데이터 전달</li></ol><blockquote id="ace3e1db-d6fd-4d20-ae1b-54e26d5c3648" class="">특징</blockquote><ul id="3f582e80-d5b7-4c8a-88c3-561106d5915e" class="bulleted-list"><li style="list-style-type:disc">데이터 단위와 패킷의 차이가 없음</li></ul><ul id="858e94d0-5502-4cb6-9a05-53f9d94b3045" class="bulleted-list"><li style="list-style-type:disc">오류가 생길 수 없는 상황이므로 수신 측이 송신 측에게 어떤 피드백도 제공할 필요가 없다.</li></ul><ul id="b628eb63-13da-4bbf-a724-1e52f277633c" class="bulleted-list"><li style="list-style-type:disc">수신자는 송신자가 데이터를 송신하자마자 수신할 수 있다고 가정해야 함</li></ul><h3 id="57097820-61f9-44b1-a285-880c7668b6f1" class="">rdt2.0: 비트 오류가 있는 채널상에서의 신뢰적인 데이터 전송</h3><ul id="646b1432-db16-4ba8-b334-a29b55f0091d" class="bulleted-list"><li style="list-style-type:disc">패킷 안의 비트들이 하위 채널에서 손상 <ul id="fe27d156-7ad0-4623-a2c7-b34aebe9c2ec" class="bulleted-list"><li style="list-style-type:circle">일반적으로 패킷이 전송되는 네트워크의 물리적인 구성 요소에서 발생함 </li></ul></li></ul><blockquote id="21e74434-c6be-4445-b8c9-4c9411ca8688" class="">자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜</blockquote><ul id="432aa2e7-f76d-4d4c-ad96-7a38d4ed82f5" class="bulleted-list"><li style="list-style-type:disc">긍정 확인응답(positive acknowledgment, “OK”)</li></ul><ul id="d3ceee2c-ea29-453d-9b8d-a3c827365a83" class="bulleted-list"><li style="list-style-type:disc">부정 확인응답(negative acknowledgment, “그것을 반복해주세요”)</li></ul><p id="52e96518-48db-4077-8d51-84b1b55217e6" class=""><strong>비트 오류를 처리하기 위한 세 가지 부가 프로토콜 기능</strong></p><ol type="1" id="03a15af9-70e6-4b42-a084-ad45ab02bc1a" class="numbered-list" start="1"><li>오류 검출</li></ol><ol type="1" id="77b21a2b-49d7-4d96-a827-e10fb3bd51d0" class="numbered-list" start="2"><li>수신자 피드백</li></ol><ol type="1" id="70e3cd33-b25f-4a5c-803f-f81f0dadecdb" class="numbered-list" start="3"><li>재전송</li></ol><blockquote id="cbe3eca7-91e2-4600-9f68-8cbc68478f72" class="">송신자</blockquote><figure id="02a53c45-6799-407a-a587-30e054ebcb3b" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%204.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%204.png"/></a></figure><p id="ec857ecc-1ffe-4caf-8d46-f14f91c50569" class="">상태</p><ol type="1" id="eb249ac5-fe00-494e-9da1-2229718e5254" class="numbered-list" start="1"><li>상위 계층으로부터 데이터 전달되기를 기다리는 중<ol type="a" id="02e49aec-86e4-4642-a424-fb6ebc2a752b" class="numbered-list" start="1"><li>체크섬과 함께 전송될 데이터를 포함하는 패킷 생성</li></ol><ol type="a" id="eaf5c776-efb6-4149-8857-409e95f2698b" class="numbered-list" start="2"><li>udt_send(sndpkt) 통해 전송</li></ol></li></ol><ol type="1" id="229a2408-0cfc-4dec-aa97-4e857ea4e335" class="numbered-list" start="2"><li>수신자로부터 ACK 또는 NAK 기다리는 중<ol type="a" id="bf977f1f-74f4-45a8-96cc-f84733d615a6" class="numbered-list" start="1"><li>ACK이 수신되면 다시 데이터 기다리는 상태로 감</li></ol><ol type="a" id="12d0547a-940e-494c-8e45-496a3dae4579" class="numbered-list" start="2"><li>NAK이 수신되면 마지막 패킷을 재전송하고, 다시 기다리는 상태가 됨 </li></ol></li></ol><blockquote id="d618dba0-67fd-4029-9b81-d02663f07de5" class="">수신자</blockquote><figure id="a8d5bd73-0e62-437a-b222-ab6a3d7f79d7" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%205.png"><img style="width:572px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%205.png"/></a></figure><ul id="0db7b9c1-43e6-4732-829e-9c3047815e0f" class="bulleted-list"><li style="list-style-type:disc">패킷이 도착했을 때, 패킷이 손상되었으면 NAK, 아니면 ACK로 응</li></ul><blockquote id="22fc8b89-b3c6-46ea-96fb-185a1f07ca4d" class="">특징</blockquote><ul id="046fa994-ed61-4a98-a044-b9cee6450bc2" class="bulleted-list"><li style="list-style-type:disc">기다리는 상태에서 데이터를 받을 수 없음 → 그래서 전송 후 대기(stop-and-wait) 프로토콜 </li></ul><ul id="761eeb65-33df-462b-a7eb-096aa85dbf31" class="bulleted-list"><li style="list-style-type:disc">송신자는 수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지 새로운 데이터를 전달하지 않음 </li></ul><blockquote id="2cc85f70-2327-4621-a59c-519689828f81" class="">결함 </blockquote><ul id="6627969d-7178-4ae2-8039-d4293203807b" class="bulleted-list"><li style="list-style-type:disc">ACK, NAK도 손상될 수 있음을 고려 x </li></ul><ul id="eff66564-0573-41ee-bb72-aa8ddcae03d2" class="bulleted-list"><li style="list-style-type:disc">대안 1: 비트 오류로부터 회복할 수 있도록 충분한 체크섬 비트들 추가 </li></ul><ul id="cd9b209a-d42e-4d41-9214-b56d8d040d6a" class="bulleted-list"><li style="list-style-type:disc">대안 2: ACK, NAK 수신할 때 현재 데이터 패킷을 단순히 다시 송신<ul id="f527c5d7-7d63-4587-95c5-7c03856061a5" class="bulleted-list"><li style="list-style-type:circle">중복 패킷 </li></ul></li></ul><blockquote id="89e9971c-434a-4a66-b11e-5028b296f350" class="">해결책</blockquote><p id="a0bdb2c2-b7d7-4e35-ba7c-ee01eb23fd07" class="">데이터 패킷에 순서 번호(송신자가 번호 붙임)를 삽입하는 새로운 필드 추가</p><h3 id="9fd564c6-47f2-47b5-94bc-9e105eb1f7a9" class="">rdt2.1: rdt2.0의 수정 버전</h3><ul id="9efbdf86-1863-4f22-b712-9d28a564531f" class="bulleted-list"><li style="list-style-type:disc">2.0에 비해 상태가 두 배<ol type="1" id="9b8ebde2-bae0-4efd-a853-c37456eae21c" class="numbered-list" start="1"><li>프로토콜 상태가 현재 송신자에 의해 전송되고 있는지를 반</li></ol><ol type="1" id="31357a94-bb27-437c-a8b9-4e47b949848d" class="numbered-list" start="2"><li>수신자가 기다리고 있는 패킷이 순서 번호 0 또는 1을 가져야 하는지를 반영</li></ol></li></ul><ul id="3d4effd0-be2b-43ce-af4a-44a8ef24383e" class="bulleted-list"><li style="list-style-type:disc">긍정 확인응답과 부정 확인응답을 포함<ul id="34881259-495e-4fda-8b9f-9347534343df" class="bulleted-list"><li style="list-style-type:circle">순서가 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인응답 전송</li></ul><ul id="26d474d4-1b03-47a4-b5dd-2c2f39512c58" class="bulleted-list"><li style="list-style-type:circle">손상된 패킷이 수신되면, 수신자는 부정 확인응답을 전송 </li></ul></li></ul><ul id="058fb7cb-11f8-4677-89d0-d6982b585b89" class="bulleted-list"><li style="list-style-type:disc">NAK 대신 가장 최근에 정확하게 수신된 패킷에 대해 ACK 송신 <ul id="05e2090e-5864-4d66-af79-d4f50344eb1f" class="bulleted-list"><li style="list-style-type:circle">같은 패킷에 대해 2개의 ACK를 받은 송신자는 수신자가 두 번 ACK한 패킷의 다음 패킷을 수신하지 못한 것을 알게 된다.</li></ul></li></ul><blockquote id="e35bf714-28c4-47b4-b82a-6f6eebf2a1e4" class="">송신자</blockquote><figure id="70e9f99d-42e2-4613-885a-7d8acb60bae3" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%206.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%206.png"/></a></figure><blockquote id="6c7394a7-920f-498b-b56e-8d25853136e3" class="">수신자</blockquote><figure id="73209d7e-57d5-4d57-82f3-9a710a7f9406" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%207.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%207.png"/></a></figure><p id="50070f7b-0d5f-43e8-9035-d2fb0647f80e" class="">
</p><h3 id="55748acc-b924-4a5d-95c4-4da0786b5aa4" class="">rdt2.2: 비트 오류를 갖는 채널을 위한 NAK 없는 신뢰적인 데이터 전송 프로토콜</h3><p id="d5554af6-9023-4044-a3cc-03eacf160ecf" class="">rdt2.1과 다르게</p><ol type="1" id="0e031d89-74c1-4952-a980-9a5ff9726979" class="numbered-list" start="1"><li>수신자가 반드시 ACK 메시지에 의해 확인 응답되는 패킷의 순서 번호를 포함 <ol type="a" id="c8319b7a-957e-4cce-8693-10d718b13f3f" class="numbered-list" start="1"><li>make_pkt(ACK, 0) or make_pkt(ACK, 1) </li></ol></li></ol><ol type="1" id="5c7f8c81-0fd7-41ed-970d-5dec765060c7" class="numbered-list" start="2"><li>송신자는 수신된 ACK 메시지에 의해 확인 응답된 패킷의 순서 번호를 반드시 검사 <ol type="a" id="3839c8fc-92aa-4716-b491-4ca6c43ad03b" class="numbered-list" start="1"><li>isACK(0 or 1)</li></ol></li></ol><blockquote id="e73f8f5b-b441-4d47-8a02-ac449cf6f13a" class="">송신자</blockquote><figure id="bfb72b93-40da-47e7-a40d-0227753c1987" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%208.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%208.png"/></a></figure><blockquote id="6eef7b57-c9b0-4c69-bc4c-9290c8d2ab9a" class="">수신자</blockquote><figure id="90f0b7fa-d580-41de-a16a-8192564898d6" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%209.png"><img style="width:1079px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%209.png"/></a></figure><h3 id="983f31d4-d266-41f4-a1cf-cc09dc6df585" class="">rdt3.0: 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송</h3><ul id="33626e4d-2ad3-4144-8b12-aeddfa5240fc" class="bulleted-list"><li style="list-style-type:disc">하위 채널이 패킷을 손실하는 경우<ol type="1" id="e18f7786-49c6-4d6b-b382-655ebcc2d357" class="numbered-list" start="1"><li>어떻게 패킷 손실을 검출할 것인가?</li></ol><ol type="1" id="f5140585-6aff-40de-8ff2-1ecbc42cf3f0" class="numbered-list" start="2"><li>패킷 손실이 발생했을 때 어떤 행동을 할 것인가?</li></ol></li></ul><ul id="04838dce-8dc5-4969-a42e-d1eb79f19f13" class="bulleted-list"><li style="list-style-type:disc">송신자에게 손실된 패킷의 검출과 회복에 대한 책임을 부여</li></ul><ul id="feac4bdb-1c6a-46b0-a225-b99ee9ec01e6" class="bulleted-list"><li style="list-style-type:disc">송신자가 패킷을 잃어버렸다고 확실한 정도로 충분한 시간을 기다림<ul id="889091c7-c076-46d5-8080-e8f91a205d24" class="bulleted-list"><li style="list-style-type:circle">충분한 시간: 송신자와 수신자 사이의 왕복 시간 지연(중간 라우터 버퍼링 포함) + 수신 측에서 패킷을 처리하는 데 필요한 시간</li></ul><ul id="ad748017-24bb-4b05-8163-74e85f8c4d77" class="bulleted-list"><li style="list-style-type:circle">시간 안에 수신되지 않으면 패킷은 재전송된다.</li></ul></li></ul><ul id="16672a44-d941-4cc8-b269-3c583de48403" class="bulleted-list"><li style="list-style-type:disc">주어진 시간이 지난 후에 송신자를 인터럽트할 수 있는 카운트다운 타이머가 필요 </li></ul><ol type="1" id="a2f4e672-5c6a-421b-a520-a7e6910ecd45" class="numbered-list" start="1"><li>매 패킷이 송신된 시간에 타이머 시작</li></ol><ol type="1" id="941f9878-23f4-4625-b1c0-55e51e0174a2" class="numbered-list" start="2"><li>타이머 인터럽트에 반응</li></ol><ol type="1" id="db08fa72-f61e-4344-8512-b38a57df7241" class="numbered-list" start="3"><li>타이머 멈춤</li></ol><blockquote id="a60ad6f7-1946-40d3-b03d-73d963989a92" class="">송신자</blockquote><figure id="3474552f-04d3-455f-a952-ef586782ca79" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2010.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2010.png"/></a></figure><blockquote id="611de756-4a70-41c3-99a9-49348ae78278" class="">동작과 처리 과정</blockquote><ul id="578b675b-e3b9-47d1-b845-0dcf075c0a7e" class="bulleted-list"><li style="list-style-type:disc">패킷에 대한 수신 시간은 전송 지연 + 전파 지연 때문에 패킷 전송 시간보다 크다.</li></ul><ul id="d80f1040-46a7-4bbb-b1d8-04be8d2e62a4" class="bulleted-list"><li style="list-style-type:disc">패킷의 순서 번호과 0, 1 번걸아 일어나기 때문에 rdt3.0은 얼터네이팅 비트 프로토콜(alternating-bit protocol)이라고 불림</li></ul><p id="587ed25a-0108-40a5-9978-59870fc3418d" class="">(a) 무손실 동작</p><figure id="3ba430db-6a89-43c9-bb72-4cd148ef5014" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2011.png"><img style="width:432px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2011.png"/></a></figure><p id="3d412a7d-6464-4e95-b034-d701e4da7971" class="">(b) 패킷 손실</p><figure id="4032d3fb-7ed5-4f75-b1f9-48d60baaefe5" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2012.png"><img style="width:438px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2012.png"/></a></figure><p id="5c88ec09-aa4c-4778-a999-0408e90456df" class="">(c) ACK 손실</p><figure id="6c3f856f-ca1e-43d3-9a08-e0d03c1a8711" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2013.png"><img style="width:424px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2013.png"/></a></figure><p id="704704f6-d0b0-4079-ad96-1bf54b9bb760" class="">(d) 조급한 타임아웃</p><figure id="ceb43fe0-26d1-450c-b841-7fe460150a49" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2014.png"><img style="width:541px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2014.png"/></a></figure><h2 id="5afde603-8af7-4ce2-9655-696bf18af51c" class="">파이프라이닝된 신뢰적인 데이터 전송 프로토콜</h2><ul id="49d7ec0e-acfa-43f4-882a-85539865b5f6" class="bulleted-list"><li style="list-style-type:disc">rdt3.0의 핵심적인 성능 문제: 전송 후 대기 프로토콜이라는 점, 송신자 이용률이 형편 없다.</li></ul><p id="377ecfaf-fe1d-40e6-96da-77a35c69d05c" class="">→ 오늘날 고속 네트워크에서 만족할 수 없는 성능</p><ul id="7d8f0965-07cd-4bd6-ac17-fb0d8495a846" class="bulleted-list"><li style="list-style-type:disc">해결책: 송신자에게 확인 응답을 기다리기 전에 송신을 전송하도록 허용, 파이프라이닝</li></ul><figure id="eabffb0d-6d17-4b99-b2a2-45850c8f98fb" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2015.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2015.png"/></a></figure><ul id="4862bb35-9738-41c4-b4a2-89d8846647a9" class="bulleted-list"><li style="list-style-type:disc">순서 번호의 범위가 커져야 함<ul id="6bbc268c-bd26-4bbb-a7b3-6e01b30f20cf" class="bulleted-list"><li style="list-style-type:circle">전송 중인 패킷은 유일한 순서 번호를 가져야 함</li></ul></li></ul><ul id="224aef44-e6fb-4f63-9f30-92ef9ff70ac5" class="bulleted-list"><li style="list-style-type:disc">프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 함</li></ul><ul id="20676e48-e919-4b55-9151-d77bef34d7d5" class="bulleted-list"><li style="list-style-type:disc">필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷, 손상 패킷, 지연 패킷에 대해 응답하는 방식에 달려 있음</li></ul><h2 id="b385b616-9725-44f2-a320-27046162286f" class="">GBN</h2><ul id="bdf32556-d4da-439c-b488-aa4ba10446f8" class="bulleted-list"><li style="list-style-type:disc">Go-Back-N, N부터 반복</li></ul><ul id="3b6ff154-eb83-4620-92d8-be02f1112ef3" class="bulleted-list"><li style="list-style-type:disc">송신자는 확인 응답을 기다리지 않고 여러 패킷을 보낼 수 있다. </li></ul><ul id="8a6e197a-d804-46ee-925a-a5d03e188c84" class="bulleted-list"><li style="list-style-type:disc">파이프라인에서 확인 응답 안 된 패킷의 최대 허용 수가 N보다 크면 안 됨</li></ul><figure id="cf47baf2-2b21-4a05-82e0-30102b40acf6" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2016.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2016.png"/></a></figure><ul id="c39307f6-b0dd-402b-a38f-2b32deeec97f" class="bulleted-list"><li style="list-style-type:disc">슬라이딩 윈도우 프로토콜</li></ul><ul id="513d65d0-bc88-4cbb-9906-74ee83d570d5" class="bulleted-list"><li style="list-style-type:disc">패킷의 순서 번호: 패킷 헤더 안의 고정된 길의 필드에 포함<ul id="a2f364bc-7c57-4315-ac8a-53fd47c725c8" class="bulleted-list"><li style="list-style-type:circle">패킷 순서 번호 필드의 비트 수가 k라면 [0, 2^k - 1]</li></ul><ul id="b274e63f-757d-4605-9348-959f8b3fcc3a" class="bulleted-list"><li style="list-style-type:circle">모듈로 연산 </li></ul></li></ul><p id="57e06501-c783-4905-afe9-d93d90a768d6" class=""><strong>ACK 기반의 NAK 없는 확장된 FSM</strong></p><ul id="ef4c580c-2d1c-4e6e-963f-8ede39ec3cc4" class="bulleted-list"><li style="list-style-type:disc">base와 nextseqnum 추가</li></ul><blockquote id="0c50f2db-81a5-494e-9e24-693c90508eee" class="">송신자</blockquote><figure id="54a32614-f13b-4189-b631-1009247ddc92" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2017.png"><img style="width:956px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2017.png"/></a></figure><ul id="092e9510-2332-46db-8980-662d75805f52" class="bulleted-list"><li style="list-style-type:disc">송신자가 반응해야 할 세 가지 타입의 이벤트</li></ul><ol type="1" id="2cd237bc-04bf-469b-af61-db276df6e883" class="numbered-list" start="1"><li>상위로부터의 호출</li></ol><ol type="1" id="d3f307c4-4c3a-4b60-9766-05f11d27543a" class="numbered-list" start="2"><li>ACK의 수신</li></ol><ol type="1" id="dab6d72f-c1e3-4e63-9ec9-278697c53ad6" class="numbered-list" start="3"><li>타임아웃 이벤트 </li></ol><blockquote id="23200fe6-bcaf-4b32-8108-ec815950693f" class="">수신자</blockquote><figure id="e3123398-340f-4a65-a3f7-bb52fff55c5f" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2018.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2018.png"/></a></figure><ul id="9afe6324-5997-4f29-b9af-23b76bf008ec" class="bulleted-list"><li style="list-style-type:disc">패킷이 오류 없이 순서대로 수신되면 ACK 보내고 상위 계층에 패킷의 데이터를 전달 </li></ul><ul id="669a3674-492d-45d7-8c3a-c756d9a43fc1" class="bulleted-list"><li style="list-style-type:disc">그 외의 경우에는 수신자가 그 패킷을 버리고 가장 최근에 제대로 수신된 순서의 패킷에 대한 ACK를 재전송</li></ul><blockquote id="325e466f-2e6a-43a5-8b06-17737ed99ceb" class="">GBN 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다.</blockquote><p id="9e03439e-35ac-4140-a513-d31904de36ed" class="">패킷 n이 수신되어야 할 때 패킷 n+1이 먼저 도착했다고 가정</p><p id="b8b835c7-e467-4063-a410-14572a3785d0" class="">수신자는 패킷 n+1을 저장하고 나중에 패킷 n이 수신되면 차례대로 전달</p><p id="6e73a167-e03c-4e32-8aad-7a585b546f30" class="">그러나 패킷 n이 손실된다면 송신자에게 GBN 재전송 규칙에 따라 패킷 n, n+1이 모두 재전송</p><ul id="624eecfa-3a89-41cb-850a-4f27df1b4736" class="bulleted-list"><li style="list-style-type:disc">윈도 크기 4 패킷인 경우의 GBN 프로토콜 동작</li></ul><figure id="4e0debe1-b69c-4292-b0ed-254e945d3837" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2019.png"><img style="width:608px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2019.png"/></a></figure><p id="d47b2dc6-a999-43d0-88d1-12754d0a4d3f" class=""><strong>성능 문제</strong></p><p id="3c29b183-9ec3-46a5-8b6d-ee85cf1fb377" class="">GBN 자체 성능 문제: </p><ul id="5a360a4a-98e2-424c-be72-858e5a01b21d" class="bulleted-list"><li style="list-style-type:disc">윈도 크기와 대역폭 지연 곱의 결과가 클 때, 많은 패킷이 파이프라인에 존재</li></ul><ul id="b6231fe3-0efd-411a-b285-0bd92188d3d1" class="bulleted-list"><li style="list-style-type:disc">하나의 오류 때문에 많은 패킷을 재전송해야되는데 불필요하게 많은 패킷을 전송해야 함</li></ul><h2 id="2973f2fc-06b7-438a-9d0b-fedf5a8b4741" class="">SR</h2><ul id="8e6d708c-9acd-4ca4-a5a9-9de9b7dc6775" class="bulleted-list"><li style="list-style-type:disc">Selective Repeat, 선택적 반복</li></ul><ul id="c42a83f1-ccca-4f6f-903f-697986abafac" class="bulleted-list"><li style="list-style-type:disc">수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만 재전송<ul id="47d5682b-e588-4daa-b684-fc6c4c099897" class="bulleted-list"><li style="list-style-type:circle">불필요한 재전송 피함</li></ul><ul id="3d72527c-2c5d-4d93-84b6-7005cd1cd593" class="bulleted-list"><li style="list-style-type:circle">패킷에 대하 개별적인 확인응답 요구</li></ul></li></ul><ul id="ca211a65-ce98-4f5e-afc8-14b0c605d56b" class="bulleted-list"><li style="list-style-type:disc">윈도 크기 N: 아직 확인응답이 안 된 패킷 수를 제한하는 데 사용</li></ul><figure id="bdd18317-3402-437c-8eaa-c72e2c10a5f3" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2020.png"><img style="width:895px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2020.png"/></a></figure><ol type="1" id="dec6bd02-c210-47fb-80fa-6b8cc965280d" class="numbered-list" start="1"><li>순서가 바뀐 패킷은 빠진 패킷이 수신될 때까지 버퍼에 저장하고</li></ol><ol type="1" id="16612791-1dfc-41cb-98c6-4cd4ffcdbad2" class="numbered-list" start="2"><li>빠진 패킷이 수신된 시점에서 일련의 패킷을 순서대로 상위 계층에 전달</li></ol><p id="91db1446-d6ea-42a9-a084-5d726819cbbb" class=""><strong>SR 송신자 이벤트와 행동</strong></p><ol type="1" id="4755f190-4bf8-4073-87ac-ea65d8e261bb" class="numbered-list" start="1"><li>상위로부터 데이터 수신</li></ol><ol type="1" id="676c9d89-4b79-4038-9cb5-48471178684c" class="numbered-list" start="2"><li>타임아웃</li></ol><ol type="1" id="12890add-a6e9-4a3c-91c4-ca3935b06f6c" class="numbered-list" start="3"><li>ACK 수신</li></ol><p id="2e413354-2a9f-449c-9e0f-10dd100db4ab" class=""><strong>SR 수신자 이벤트와 행동</strong></p><ol type="1" id="c91032c1-1896-4b81-bb2d-586297911ced" class="numbered-list" start="1"><li>[rcv_base, rcv_base+N-1] 내의 순서 번호를 가진 패킷이 손상 없이 수신된다.</li></ol><ol type="1" id="146b2ad9-869d-4c2e-b9c9-7063052dd66b" class="numbered-list" start="2"><li>[rcv_base-N, rcv_base-1] 내의 순서 번호를 가진 패킷이 수신된다.</li></ol><ol type="1" id="dfbefd36-02d9-489b-8dd0-7a5c454d9f03" class="numbered-list" start="3"><li>그 외 패킷 무시</li></ol><p id="d8b03ad7-3c79-455b-8527-9f964048538b" class=""><strong>SR 동작</strong></p><figure id="a1897cc9-4849-4ec0-981e-2404f0926e0e" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2021.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2021.png"/></a></figure><blockquote id="f925cd75-b7f3-4008-9785-c04be09178b4" class="">송신자와 수신자의 윈도는 항상 같지 않다</blockquote><p id="3b5228ec-d0b1-4f40-aca0-11668f531928" class="">송신자가 보낸 패킷에 대한 응답이 없으면 송신자의 윈도는 절대 앞으로 안 감 </p><p id="39a65e51-b3e5-4505-9bf7-31de7c5448a0" class=""><strong>가정</strong></p><p id="27518ad1-fc79-4ff0-8c29-da2fd3b093bd" class="">패킷 순서 번호 0, 1, 2, 3<br/>윈도 크기 3<br/>0 ~ 2는 올바르게 수신, 확인 완료<br/>수신자 윈도: 순서 번호가 각각 3, 0, 1인 패킷<br/></p><p id="8ea16451-f42a-4cf1-8307-20952c84a380" class=""><strong>첫 번째 시나리오</strong></p><figure id="d7f0276a-8430-4dbf-91a4-8b7bc8240669" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2022.png"><img style="width:677px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2022.png"/></a></figure><ol type="1" id="7cb0bd48-cb7c-4e05-8111-d0c974905b4b" class="numbered-list" start="1"><li>처음 3개 패킷에 대한 ACK 손실, 송신자는 이 패킷 재전송</li></ol><ol type="1" id="08782dbd-e449-40e7-bf1d-ea0198e663e1" class="numbered-list" start="2"><li>수신자는 순서 번호가 0인 패킷을 수신</li></ol><p id="4f2f49c7-cb1e-496c-986e-2318858f839f" class=""><strong>두 번째 시나리오</strong></p><figure id="9dbb7096-d780-43e4-89d4-10dee909022e" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2023.png"><img style="width:664px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2023.png"/></a></figure><ol type="1" id="9b796da7-e864-40ba-a61f-408d073427d0" class="numbered-list" start="1"><li>처음 3개 ACK까지 올바르게 전달됨</li></ol><ol type="1" id="8ad8e93a-9bb1-4698-aa9f-75db60a32b07" class="numbered-list" start="2"><li>송신자는 자신의 윈도를 앞으로 이동시켜, 각각의 순서 번호가 3, 0, 1인 4, 5, 6번재 패킷을 보냄 </li></ol><ol type="1" id="fdcbd8ba-19c5-4ee0-802b-3c1cbd1fe242" class="numbered-list" start="3"><li>순서 번호 3을 가진 패킷이 손실되고, 순서 번호 0을 가진 패킷(<strong>새로운</strong> 데이터를 포함한 패킷)은 도착</li></ol><p id="69c6260e-62c8-43c5-944b-a778de919288" class=""><strong>수신자 관점</strong></p><p id="e4d1b5b0-31ec-46cf-b7aa-8f016a87c50f" class="">수신자는 송신자의 행동을 볼 수 없다.</p><p id="3f59c070-9df6-4b64-be75-6df5ac3c7795" class="">다섯 번째 패킷의 원래 전송과 첫 번째 패킷의 재전송을 <strong>구별할 방법은 없다.</strong></p><p id="ee2d6e35-77d8-49db-9007-665eb992da17" class=""><strong>최소한의 윈도 크기</strong></p><p id="7f872239-ccf8-46f9-b55b-3b7f61991d1f" class="">SR 프로토콜에 대한 순서 번호 공간 크기의 절반보다 작거나 같아야 한다.</p><p id="c51da2b0-9523-4773-bf30-d0bf14354a35" class=""><strong>패킷 순서 바뀜 현상</strong></p><p id="d0469a12-ca1b-4db6-94be-7a910b20c126" class="">패킷들은 송신자와 수신자 사이의 채널 안에서 순서가 바뀔 수 없다.</p><p id="4c3cbe7b-c65a-4522-bb18-a742e6714d8c" class="">→ 일반적으로 송신자와 수신자가 단일한 물리적 선으로 연결되어 있을 때 적합한 가정이다.</p><p id="861dfe5d-b662-4805-bdcf-52a73ea86f36" class="">하지만 둘을 연결하는 ‘채널’이 네트워크일 때는 패킷 순서 바뀜이 일어날 수 있다.</p><p id="913166e9-5e43-4f87-9555-ddd67aa764b4" class=""><strong>신뢰적인 데이터 전송 메커니즘과 그 사용에 대한 요약</strong></p><figure id="948e0bb8-6119-4e9f-83f2-55ed0026b1ab" class="image"><a href="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2024.png"><img style="width:708px" src="3%EF%B8%8F%E2%83%A3%20Network%20Layer%20c5bbc9372fcb4b4eb25f859e883a68e2/Untitled%2024.png"/></a></figure></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>