# 3. transport layer 2

## **1. 연결지향형 트랜스포트: TCP**

### TCP 연결

TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에게 보내기 전에, 두 프로세스가 **서로 ’핸드셰이크’를 먼저 해야 하므로** `연결지향형(connection-oriented)` 이다.
 → 데이터 전송을 보장하는 파라미터들을 각자 설정하기 위한 어떤 사전 세그먼트들을 보내야 함

**TCP 연결 과정**

- `클라이언트 프로세스(client process)` : 연결을 초기화하는 프로세스
- `서버 프로세스(server process)`

**TCP 세그먼트(TCP segment)**

> TCP 헤더 + 클라이언트 데이터
> 
1. 네트워크 계층에 전달되어 `네트워크 계층 IP 데이터그램` **안에 각각 캡슐화된다.**
2. `세그먼트`는 네트워크로 송신된다.
3. TCP가 상대에게서 세그먼트를 수신했을 때, 세그먼트의 데이터는 TCP 연결의 `수신 버퍼`에 위치한다.
    
    → 애플리케이션은 이 버퍼로부터 데이터의 스트림을 읽는다.
    ![Untitled](https://github.com/SSAFY-CSStudy/Network/assets/101400650/90871b56-02c0-4dfd-a7c0-300682f1218b)
    
    TCP 연결은 한쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과
    
    다른 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결의 집합으로 이루어진다.
    

### **TCP 세그먼트 구조**
![Untitled 1](https://github.com/SSAFY-CSStudy/Network/assets/101400650/af003325-8362-4659-9090-cf34310d2628)

- `출발지와 목적지 포트 번호(source and destination port number)`
- `체크섬 필드(checksum field)`
- 32비트 `순서 번호 필드(sequence number field)`
- 32비트 `확인응답 번호 필드(acknowledgement number field)`
- 16비트 `수신 윈도(receive window)` : 흐름 제어
- 4비트 `헤더 길이 필드(header length field)` : 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다.
- `옵션 필드(option field)`이 필드는 선택적이고 가변적인 길이를 가진다.송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용된다.
- `플래그 필드(flag field)` : 6비트를 포함한다.
    - `ACK` 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는 데 사용된다.
    - `RST`, `SYN`, `FIN` 비트 : 연결 설정과 해제에 사용된다.
    - `PSH` 비트 : 이 비트가 설정되었다면 이것은 수신자가 데이터를 상위 계층에 즉시 전달해야 함을 가리킨다.
    - `URG` 비트
        - 이 세그먼트에서 송신 측 상위 계층 개체가 ‘긴급’으로 표시하는 데이터임을 가리킨다.
        - 이 긴급 데이터의 마지막 바이트의 위치는 16비트의 `긴급 데이터 포인터 필드(urgent data pointer field)`에 의해 가리켜진다.
        

**순서 번호**

- TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다.
- 세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호
    - 데이터 스트림은 500,000 바이트로 구성된 파일이라고 가정한다.
    - MSS는 1,000 바이트
    - 데이터 스트림의 첫 번째 바이트는 0으로 설정한다.
        ![Untitled 2](https://github.com/SSAFY-CSStudy/Network/assets/101400650/22c20e0b-4eb0-4788-a1c7-0226cf221a4c)
        

### 확인 응답 번호

- TCP는 전이중 방식: 호스트 A가 호스트 B로 데이터를 송신하는 동안에 호스트 B로부터 데이터를 수신하게 해줌

호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어오는 데이터에 대한 순서 번호를 갖는다

→ `확인 응답 번호` :  호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호

- Ex) 호스트 A가 호스트 B로부터 `0 ~ 535의 바이트를 포함하는 어떤 세그먼트` 와 `900 ~ 1,000의 바이트를 포함하는 또 다른 세그먼트`를 수신했다고 가정
    
    호스트 A는 B의 데이터 스트림을 재생성하기 위해 536번째 바이트를 아직 기다리고 있다. 그러므로 B에 대한 A의 다음 세그먼트의 확인 응답 번호 필드에 536을 가질 것이다.
    
    > TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에,
    > 
    > 
    > TCP는 `누적 확인응답(cumulative acknowledgment)`을 제공한다고 한다.
    > 
    - 이 상황에서 호스트의 행동은?
        
        TCP RFC는 TCP 연결에서 순서가 바뀐 세그먼트를 수신할 때 호스트가 어떤 행동을 취해야 하는지에 대한 어떤 규칙도 부여하지 않았고, TCP 구현 개발자에게 맡기고 있다
        
        - 선택지
            1. 수신자가 순서가 바뀐 세그먼트를 즉시 버린다
            2. 수신자는 순서가 바뀐 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해 기다린다. → 대역폭 관점에서 효율적, 실이용
    

## **왕복 시간(RTT) 예측과 타임아웃**

- TCP는 손실 세그먼트를 발견하기 위해 `타임아웃/재전송 매커니즘`을 사용
- 타임아웃은 연결의 RTT 보다 좀 커야 함

**RTT(Round -trip time) 예측**

- RTT : 세그먼트가 전송된 시간부터 긍정 확인응답될 때까지의 시간
- `SampleRTT` 세그먼트에 대한 RTT 샘플 : 세그먼트가 송신된 시간(IP에게 넘겨진 시간)으로 부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 시간 길이
    - 어떤 시점에서 `SampleRTT`는 **전송되었지만 현재까지 확인응답이 없는 세그먼트 중 하나에 대해서만** 측정
    - 이는 대략 왕복 시간마다 `SampleRTT`의 새로운 값을 얻게 함
- Sample RTT 값은 라우터에서 혼잡과 종단 시스템에서의 부하 변화 때문에 세그먼트마다 다르기 때문에 `SampleRTT 값의 평균값` 채택 
→ TCP는 `SampleRTT 값의 평균값(EstimatedRTT)` 유지
    
    `EstimatedRTT = (1 - α) × EstimatedRTT + α × SampleRTT (권장되는 α의 값 : 0.125)`
    
    - EstimatedRTT는 SampleRTT의 가중평균
        - 최근 샘플에 높은 가중치를 준다
        - 최신 샘플들이 네트워크 상의 현재 혼장을 더 잘 반영 
        →`지수적 가중 이동 평균(exponential weighted moving average, EWMA)`
    ![Untitled 3](https://github.com/SSAFY-CSStudy/Network/assets/101400650/3d30daa2-eca5-4418-b647-4b720d071eff)

    ![Untitled](3%20transport%20layer%202%20731e93807cfb474ea99891b4f64c8b08/Untitled%203.png)
    

## **신뢰적인 데이터 전송**

- 프로세스가 자신의 수신 버터로부터 읽은 데이터 스트림이 손상되지 않음을 보장
- 중복이 없다는 것과 순서가 유지된다는 것을 보장

### **1. TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트**

1. 상위 애플리케이션으로부터 수신된 데이터
    1. TCP는 애플리케이션으로 부터 데이터를 받고
    2. 세그먼트로 이 데이터를 캡슐화
    3. IP에게 이 세그먼트를 넘긴다
    
    > 각 세그먼트는 세그먼트의 첫 번째 데이터 바이트의 바이트 열 번호인 순서 번호를 포함TCP는 이 세그먼트를 IP로 넘길 때 `타이머`를 시작
    > 
2. 타이머 타임아웃
    1. TCP는 타임아웃 이벤트에 대해 타임아웃을 일으킨 세그먼트를 재전송하여 응답
    2. 타이머 다시 시작
3. 수신 확인응답 세그먼트(ACK) 수신
    
    TCP는 변수 `SendBase` 와 ACK 값 `y`를 비교
    
    - SendBase : 수신 확인 응답이 확인되지 않은/ 가장 오래된 바이트의 순서 번호
    - SendBase-1 : 수신자에게서 정확하게 차례대로 수신되었음을 알리는 마지막 바이트의 순서번호

### 2. 3가지 시나리오

- **손실된 확인응답에 기인하는 재전송**
    - 긍정 확인 응답 손질
    - 
    
    1. 타임아웃이 발생한다.
    2. 호스트 A는 같은 세그먼트를 B에게 재전송한다.
    3. 호스트 B의 TCP는 재송신된 세그먼트의 바이트를 버린다.
    ![Untitled 4](https://github.com/SSAFY-CSStudy/Network/assets/101400650/24fd7a92-3391-4e9e-9508-d23e6fd794db)

    ![Untitled](3%20transport%20layer%202%20731e93807cfb474ea99891b4f64c8b08/Untitled%204.png)
    
- **세그먼트 100이 재전송되지 않은 경**
    - 호스트 A가 연속해서 두 세그먼트를 전송, 타임아웃 이전에 어떠한 긍정 확인응답도 수신하지 못한다고 가정
    
    1. 호스트 A는 `순서 번호 92`로 첫 번째 세그먼트를 재전송한다.
    2. 타이머를 다시 시작한다.
    3. 새로운 타임아웃 이전에 두 번째 세그먼트에 대한 ACK가 도착하는 한, **두 번째 세그먼트는 재전송을 하지 않을 것이다.**
    ![Untitled 5](https://github.com/SSAFY-CSStudy/Network/assets/101400650/60452bdf-c8dc-4617-aacf-caccf25df8a2)

    ![Untitled](3%20transport%20layer%202%20731e93807cfb474ea99891b4f64c8b08/Untitled%205.png)
    
- **누적 확인응답은 첫 번째 세그먼트의 재전송을 방지**
    - 호스트 A가 연속해서 두 세그먼트를 전송
    
    첫 번째 세그먼트의 긍정 확인응답이 네트워크에서 분실되었지만,
    
    **첫 번째 세그먼트의 타임아웃 전에** 호스트 A가 **긍정 응답번호 120의** `긍정 확인응답을 수신하면`
    
    - 호스트 A는 호스트 B가 119바이트까지 **모든** 데이터를 수신했음을 알게 된다.
    - 그러므로 호스트 A는 두 세그먼트 중 **어느 것도 재전송하지 않는다.**
    ![Untitled 6](https://github.com/SSAFY-CSStudy/Network/assets/101400650/9fa5cfae-96ed-4377-a213-571b8eaeaa15)
    

### 3. 빠른 재전송

1. 수신자가 중복 ACK를 보내는 이유
    
    : TCP는 부정 확인응답을 사용하지 않으므로, 수신자는 송신자에게 부정확인 응답을 보낼 수 없음
    
    1. TCP 수신자가 기다리는 다음 것보다 더 큰 순서 번호를 가진 세그먼트를 받았을 때, TCP 수신자는 손실 세그먼트를 찾아냄
    2. 수신자는 마지막으로 수신된 순차적인 바이트를 갖는 데이터를 다시 확인응답 → `중복 ACK` 를 생성
2. TCP ACK 생성 권고
    - 이벤트 1
        
        기다리는 순서 번호를 가진 ‘순서가 맞는’ 세그먼트의 도착, 기다리는 순서 번호까지의 **모든 데이터를 이미 확인응답 된다**
        
        - 수신자 동작 : 지연된 ACK
            1. 또 다른 ‘순서가 맞는’ 세그먼트의 도착을 위해 500ms 까지 기다린다.
            2. 만약 다음 ‘순서에 맞는’ 세그먼트가 이 기간에 도착하지 않으면, 그냥 ACK를 보냄
    - 이벤트 2
        
        기다리는 순서 번호를 가진 ‘순서가 맞는’ 세그먼트의 도착 **ACK 전송을 기다리는** 다른 하나의 ‘순서에 맞는’ 세그먼트가 있다.
        
        - 수신자 동작 : 2개의 ‘순서가 맞는’ 세그먼트들을 ACK하기 위해, `하나의 누적된 ACK`를 즉시 보냄
    - 이벤트 3
        
        **기다리는 것보다 높은 순서 번호를 가진** ‘순서가 바뀐’ 세그먼트의 도착 격자가 발견된다.
        
        - 수신자 동작 : 순서 번호가 다음의 기다리는 바이트(즉, 격차의 최솟값)를 나타내는 `중복 ACK`를 즉시 보낸다.
    - 이벤트 4
        
        수신 데이터에서 격차를 부분적으로 또는 모두 채우는 세그먼트의 도착
        
        - 수신자 동작 : 그 세그먼트가 격차의 최솟값에서 시작한다고 하면, 즉시 `ACK` 를 보냄
    
3. **빠른 재전송 (fast retransmit)**
    
    만약 TCP 송신자가 같은 데이터에 대해 3개의 중복 확인응답을 수신한다면, 이것은 ACK된 세그먼트의 다음 3개의 세그먼트가 분실되었음을 의미
    
    - 3개의 중복 ACK를 수신할 때, TCP는 **세그먼트의 타이머가 만료되기 전에** 재전송 되었다
        ![Untitled 7](https://github.com/SSAFY-CSStudy/Network/assets/101400650/66d056b9-30bd-464b-8888-8f63908d3cee)
        

## 흐름 제어

- TCP는 송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 애플리케이션에게 `흐름 제어 서비스(flow-control service)` 를 제공
    
    → 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게한다
    
- TCP 송신자는 IP 네트워크에서 혼잡 때문에 억제될 수도 있다 = `혼잡 제어(congestion control)`

### 과정

TCP는 `수신 윈도(receive window)` 라는 변수를 유지하여 흐름 제어를 제공

- **수신 측에서 가용한 버퍼 공간이 얼마나 되는지**를 송신자에게 알려주는데 사용된다.
- TCP는 `전이중(full-duplex)`이므로 연결의 각 측의 송신자는 별개의 수신 윈도를 유지한다.

Ex) TCP 연결상에서 호스트 A가 호스트 B에게 큰 파일을 전송한다고 가정

1. 호스트 B는 이 연결에 수신 버퍼를 할당 (`RcvBuffer`) 
2. 호스트 B의 애플리케이션 프로세스는 버퍼로부터 데이터를 읽으며 다음과 같은 변수들을 정의
    - `LastByteRead` : 호스트 B의 애플리케이션 프로세스에 의해 버퍼로부터 **읽힌** 데이터 스트림의 마지막 바이트 번호
        - `LastByteRcvd` : 호스트 B에서 네트워크로부터 도착하여 수신 버퍼에 **저장된** 데이터 스트림의 마지막 바이트 번호
        - `rwnd`
        - 수신 윈도 = **버퍼의 여유 공간**
        - 시간에 따라 여유 공간은 변하므로 이 변수는 동적이다.
![Untitled 8](https://github.com/SSAFY-CSStudy/Network/assets/101400650/8a2c9ae6-a433-453e-97eb-18d7a5983060)

1. 호스트 B는 호스트 B가 호스트 A에게 전송한느 모든 세그먼트의 윈도 필드에 현재 `rwnd` 값을 설정 → 호스트 A에게 연결 버퍼에 **얼마 만큼의 여유 공간이 있는지를 알려준다**
2. 호스트 A는 두 변수 LastByteSent와 LastByteAcked를 유지
→ LastByteSent - LastByteAcked =  호스트 A가 이 연결에 전송 확인응답이 안 된 데이터의 양

호스트 A는 연결된 동안 `LastBySent - LastByteAcked ≤ rwnd`을 보장

## **TCP 연결 관리**

하나의 호스트(클라이언트)에서 운영되는 프로세스가 다른 호스트(서버) 안의 또 다른 프로세스와 연결을 시작하길 원한다고 가정

1. 클라이언트 애플리케이션 프로세스는 서버에 있는 프로세스와 연결 설정하기를 원한다는 것을 **클라이언트 TCP에게 알린다.**
2. 클라이언트 안의 TCP는 다음과 같은 방법으로 TCP를 이용해 서버와 TCP 연결 설정을 시작한다.

### 연결의 설정 : 3 way handshake
![Untitled 9](https://github.com/SSAFY-CSStudy/Network/assets/101400650/33e046b6-b91e-4809-8f14-56d00913616a)

- 1단계
    1. 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트, `SYN 세그먼트`를 송신한다.
        - 애플리케이션 계층 데이터를 포함하지 않는다.
        - 세그먼트 헤더에 `SYN 비트`를 **1**로 설정
    2. 클라이언트는 최소 순서 번호(`client_isn`)를 임의로 선택하고, 최초의 TCP SYN 세그먼트의 `순서 번호 필드`에 이 번호를 넣는다.
    3. 이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신
- 2단계
    
    TCP SYN 세그먼트를 포함하는 `IP 데이터그램`이 서버 호스트에 도착하면,
    
    1. 서버는 데이터그램으로부터 TCP SYN 세그먼트를 추출한다.
    2. 연결에 TCP 버퍼와 변수를 할당한다.
    3. 클라이언트 TCP로 **연결 승인 세그먼트,** `SYNACK 세그먼트`를 송신한다.
        - 애플리케이션 계층 데이터를 포함하지 않는다.
        - `SYN 비트`는 **1**로 설정된다.
        - TCP 세그먼트 헤더의 `확인응답 필드`는 `client_isn+1`로 설정된다.
        - 서버는 자신의 최초의 순서 번호(`server_isn`)를 선택하고, TCP 세그먼트 헤더의 `순서 번호 필드`에 이 값을 넣는다.
- 3단계
    
    연결 승인 세그먼트를 수신하면,
    
    1. 클라이언트는 연결에 버퍼와 변수를 할당한다.
    2. 클라이언트 호스트는 서버로 **또 다른 세그먼트**를 송신한다.
        1. 클라이언트는 TCP 세그먼트 헤더의 `확인응답 필드` 안에 `server_isn+1` 값을 넣어, 서버의 연결 승인 세그먼트를 확인한다.
        2. 연결이 설정되었기 때문에 `SYN 비트`는 **0**으로 설정된다.

위 세 단계가 완료되면, 클라이언트와 서버 호스트들은 각각 서로에게 `데이터를 포함하는 세그먼트`를 보낼 수 있다, `SYN 비트`는 0으로 설정 된다.

### 연결의 종료

TCP 연결에 참여하는 두 프로세스 중 하나가 연결을 끊을 수 있다

연결이 끝날 때, 호스트의 자원(버퍼와 변수)은 회수
![Untitled 10](https://github.com/SSAFY-CSStudy/Network/assets/101400650/4c64e359-a1af-484e-ab58-fea67ca79c0d)

### TCP 상태

client TCP에서 TCP상태 변이의 일반 순서
![Untitled 11](https://github.com/SSAFY-CSStudy/Network/assets/101400650/6ea9f858-1955-483a-8e20-f5401b796b2f)

서버 TCP에서 TCP 상태 변이의 일반 순서
![Untitled 12](https://github.com/SSAFY-CSStudy/Network/assets/101400650/6b5c69a3-0848-4553-98c3-ac94ba78fae2)

## **혼잡 제어의 원리**

네트워크 혼잡의 원인 : 너무 많은 출발지가 너무 높은 속도로 데이터를 보내려고 시도

### 1. 혼잡의 원인과 비용

- 시나리오 1 : 2개의 송신자와 무한 버퍼를 갖는 하나의 라우터
    - 두 호스트 A와 B가 각각 출발지와 목적지 사이에서 단일 홉을 공유하는 연결을 갖음
    - 호스트 A와 B의 애플리케이션이 `λin 바이트/초의 평균 전송률` 로 데이터를 전송
    - 라우터 버퍼의 양은 무한하다고 가정
    ![Untitled 13](https://github.com/SSAFY-CSStudy/Network/assets/101400650/9c67543f-41ba-4b06-b7ab-382a38c4e4cf)
    
    A의 연결 성능을 나타낸다
    ![Untitled 14](https://github.com/SSAFY-CSStudy/Network/assets/101400650/d34cd488-5d14-4335-91eb-1d7e9007424d)
    
    1. 연결당 처리량(per-connection throughtput) : 수신자 측에서 초당 바이트 수
        - 0 ~ R/2 사이의 전송률 : 수신자 측의 처리량은 송신자의 전송률과 같다.
        - R/2 이상의 전송률 : 처리량은 R/2
        - 즉, 호스트 A와 B가 전송률을 아무리 높게 설정하더라도 **각자 R/2보다 높은 처리량을 얻을 수 없다.**
    
    ![Untitled 15](https://github.com/SSAFY-CSStudy/Network/assets/101400650/1a906779-8915-40eb-aa60-5890a776eaa2)
    
    1. 평균 지연
        - 전송률이 R/2에 근접할 경우 : 평균 지연은 점점 커진다
        - 전송률이 R/2를 초과할 경우 : 무제한(무한한 사용 가능한 버퍼링을 가정)
        

- **시나리오 2 : 2개의 송신자, 유한 버퍼를 가진 하나의 라우터**
    - `라우터 버퍼의 양이 유한하다`고 가정한다. → 버퍼가 가득 찼을 때 도착하는 패킷들은 버려진다.
    - `각 연결은 신뢰적`이라고 가정한다. → 패킷이 라우터에 버려지면 송신자에 의해 재전송될 것이다.
    - 애플리케이션이 원래의 데이터를 소켓으로 보내는 **송신율** : `λin 바이트/초`
    - 네트워크 안으로 세그먼트를 송신하는 트랜스포트 계층에서의 송신율**(제공된 부하, offered load)**: `λ'in 바이트/초` *= 최초의 데이터 전송과 재전송 합의 속도*
    ![Untitled 16](https://github.com/SSAFY-CSStudy/Network/assets/101400650/6d8120db-127e-43e8-9996-fa536f01ec04)

    
    1. 어떠한 손실도 발생하지 않는 경우
    2. 패킷이 확실히 손실된 것을 알았을 때만 송신자가 재전송하는 경우
    3. 송신자에서 너무 일찍 타임아웃되어 패킷이 손실되지 않았지만, 큐에서 지연되고 있는 패킷을 재전송하는 경우
- **시나리오 3 : 4개의 송신자와 유한 버퍼를 갖는 라우터, 그리고 멀티홉 경로**
    - 4개의 호스트는 겹쳐지는 `2홉 경로`를 통해 패킷을 전송한다.
    - 각각의 호스트가 타임아웃/재전송 매커니즘을 사용한다.
    - 모든 호스트는 `λin`의 동일한 값을 가진다.
    - 모든 라우터 링크는 `R 바이트/초 옹량`을 갖는다.
    ![Untitled 17](https://github.com/SSAFY-CSStudy/Network/assets/101400650/5f54eb1e-fcb7-4af7-83d9-d0533e02c010)

    부하와 처리량 간의 tradeoff가 발생
    
    → 패킷이 경로상에서 버려질 때, **버려지는 지점까지 패킷을 전송하는 데 사용된 상위 라우터에서 사용된 전송 용량은 낭비된 것**
    ![Untitled 18](https://github.com/SSAFY-CSStudy/Network/assets/101400650/308e7bf8-1213-4454-819a-89b38e8f2ff2)
    

### 2. 혼잡 제어에 대한 접근법

- 종단 간의 혼잡 제어
    1. TCP 세그먼트 손실과 증가하는 왕복 지연값을 네트워크 혼잡의 발생 표시로 간주
    2. TCP는 그에 따라서 윈도 크기를 줄인다
- 네트워크 지원 혼잡 제어
    
    라우터들은 네트워크 안에서 혼잡 상태와 관련하여 송신자난 수신자 또는 모두에게 직접적인 피드백 제공
    
    - `ATM ABR(Available Bite Rate) 혼잡 제어`에서
        
        라우터는 자신이 출력 링크(outgoing link)에 제공할 수 있는 전송률을 송신자에게 명확히 알릴 수 있게 해준다.
        
    - 최근 IP와 TCP가 이 방식을 선택적으로 구현할 수 있다.
    
    혼잡 정보가 전달되는 두 가지 방법 → 둘 중 하나로 네트워크에서 송신자에게 피드백 된다
    ![Untitled 19](https://github.com/SSAFY-CSStudy/Network/assets/101400650/df8ce555-73ae-4478-a978-f5df619bd8e7)
    
    1. **직접 피드백**
        - 네트워크 라우터 → 송신자
        - 알림의 형태 : `초크 패킷(choke packet)`
    2. 송신자에서 수신자에게로 흐르는 **패킷 안**에 특정 필드에 표시/수정
        - 수신자가 표시된 패킷을 수신했을 때, 혼잡 상태를 송신자에게 알린다.
        - 완전한 왕복 시간이 걸린다.

## 혼잡 제어

IP 계층은 네트워크 혼잡에 관해 종단 시스템에게 어떠한 직접적인 피드백도 제공하지 않는다

### TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)
![Untitled 20](https://github.com/SSAFY-CSStudy/Network/assets/101400650/62bb8256-8d8c-476c-b5c8-2588026a9e8e)


### **1. slow start**

1. TCP 연결 시작 시, `cwnd`의 값은 일반적으로 1 MSS로 초기화된다.
    
    → 초기 전송률은 대략 `MSS/RTT`
    
2. TCP 송신자에게 가용 대역폭은 MSS/RTT보다 훨씬 크기 때문에 TCP 송신자는 가용 대역폭 양을 조속히 찾고자 한다.
![Untitled 21](https://github.com/SSAFY-CSStudy/Network/assets/101400650/a33b9dad-a6cf-44c2-82cd-1e6861dc8004)


- **종료 조건**
    1. 타임아웃으로 표시되는 손실 이벤트(혼잡)가 있을 경우
        1. TCP 송신자는 cwnd 값을 1로 설정
        2. 새로운 슬로 스타트를 시작
    2. cwnd 값이 ssthreah 값과 같을 경우
        1. 슬로 스타트는 종료되고
        2. TCP는 혼잡 회피 모드로 전환
    3. 중복 ACK가 검출되는 경우
        1. TCP는 빠른 재전송을 수행하여 빠른 회복 상태로 들어간다

### **2. congestion avoidance**

혼잡 회피 상태로 들어가는 시점에서 cwnd의 값은 대략 혼잡이 마지막으로 발견되는 시점에서의 값의 반이 된다 
→ 새로운 승인이 도착할 때마다 cwnd 를 **MSS 바이트(MSS/cwnd)** 만큼 증가 시킨다

- 종료 조건
    1. 3개의 중복 ACK를 수신한 시점에서 `cwnd`의 값을 반으로 줄이고
    2. `ssthresh` 값을 `cwnd 값의 반`으로 기록한다.
    3. 이후 `빠른 회복 상태`로 들어간다.

### **3. fast recovery → 권고 사항**

`빠른 회복 상태`에서는 `cwnd` 값을 **손실된 세그먼트에 대해 수신된** 모든 중복된 ACK에 대해 `1 MSS` 만큼씩 증가시킨다.

1. 손실된 세그먼트에 대한 ACK가 도착하면 TCP는 `cwnd 혼잡 회피 상태`로 들어간다
2. 만약 타임아웃 이벤트가 발생한다면 빠른 회복은 슬로 스타트 및 혼잡 회피에서와 같은 동작을 수행한 후 슬로 스타트로 전이한다
→ cwnd 값은 1 MSS로 하고, ssthreah 값은 손실 이벤트가 발생할 때의 cwnd값의 반으로 한다

- TCP 타호(TCP Tahoe, 초기 TCP 버전) : 타임아웃으로 표시되거나 3개의 중복 ACK로 표시되는 손실이 발생하면
    1. 무조건 혼잡 윈도를 1 MSS로 줄이고
    2. **슬로 스타트 단계**로 들어간다
- `TCP 리노(TCP Reno, 새로운 TCP 버전)`는 **빠른 회복**을 채택했다.
    
    
    - TCP 리노
        1. 혼잡 윈도가 9 MSS로 설정되고
        2. 선형적으로 증가한다
    - TCP 타호
        1. 혼잡 윈도는 1 MSS로 설정되고
        2. ssthreath에 도달할 때까지 지수적으로 증가하며
        3. 그 이후에는 선형적으로 증가
    ![Untitled 22](https://github.com/SSAFY-CSStudy/Network/assets/101400650/1b6a0b4f-03eb-4f27-957a-e1d6f814749f)
    

## **명시적 혼잡 알림(Explicit Congestion Notification, ECN)**

인터넷 내에서 수행되는 `네트워크 지원 혼잡 제어`

> 손실이 발생하기 전에 혼잡 시작을 송신자에게 알리기 위해 혼잡 알림 비트를 설정한다.
> 
![Untitled 23](https://github.com/SSAFY-CSStudy/Network/assets/101400650/49cd9df6-069c-4370-ad66-6cf54637c07e)
