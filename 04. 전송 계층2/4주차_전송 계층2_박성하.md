## 세그먼트
![](https://i.imgur.com/FeQB89g.png)
- **순서 번호**, **ACK 번호** : rdt를 통해 세그먼트를 보낼 때 송신자와 수신자에 의해 사용
	![](https://i.imgur.com/LkVMTNp.png)
	- 순서 번호 : 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호
	- 응답 번호 : 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호로 확인된 번호가 누적됨
- **수신 윈도우** : flow control을 위해 사용, 수신자가 받아들이려는 바이트의 크기
- **헤더 길이**: TCP 옵션 필드의 경우 20비트를 차지하여 가변적이기 때문
- **옵션** : 송신자와 수신자가 최대 세그먼트 크기를 할당, 윈도 확장 요소, 타임스탬프 등
- **플래그**
	- ACK : 응답 값이 유용함을 가리킴
	- RST : 연결 강제 종료
	- SYN : 핸드셰이크 연결
	- FIN : TCP 연결 종료
	- PSH : 수신자가 데이터를 상위 계층에 즉시 전달해야 함 -> 평소에는 버퍼링
	- URG : 데이터를 '긴급'으로 표시 -> 우선 처리
## RTT 예측, 타임아웃
### RTT 예측
#### **SampleRTT**
- 세그먼트가 송신된 시간으로부터 그 세그먼트에 대한 ACK이 도착한 시간까지의 시간 길이
- 재전송한 세그먼트에 대해서는 측정 X
- 라우터에서의 혼잡, 종단 시스템에서의 부하 변화로 인해 세그먼트마다 다름 -> 불규칙적
#### **EstimatedRTT**
	$$EstimatedRTT = (1 - \alpha) \times EstimatedRTT + \alpha \times sampleRTT$$
- SampleRTT값의 가중 평균
- 예전 샘플보다 최근 샘플에 더 높은 가중치를 줌 -> 현재 혼잡을 반영
#### **DevRTT**
$$DevRTT = (1 - \beta) \times DevRTT + \beta \cdot |SampleRTT - EstimatedRTT|$$
- SampleRTT가 EstimatedRTT에서 얼마나 벗어났는지 예측
- SampleRTT가 같다면 DevRTT는 작아지며, 변화가 있다면 DevRTT는 커짐
### 타임아웃
- 주기는 EstimatedRTT보다 커야함 -> 작다면 재전송이 잦음
- 주기는 EstimatedRTT와 너무 차이나서는 안됨 -> 세그먼트 손실 시, 즉각적인 재전송이 이뤄지지 않음

1. 초기 TimeoutInterval = 1초
2. 타임아웃 발생 시, TimeoutInterval *= 2
3. EstimatedRTT 수정 시, $TimeoutInterval = EstimatedRTT + 4 \times DevRTT$
## 시나리오
### 1️⃣
![](https://i.imgur.com/vMQKXV7.png)

1. 92번 세그먼트에 대한 ACK 유실
2. 송신측(Host A)에서 TimeInterval 내에 ACK을 받지 못했으므로 92번 세그먼트 재전송
3. 수신측(Host B)는 92번 세그먼트가 재전송임을 알고 있으므로 해당 세그먼트를 버리고, ACK 전달

### 2️⃣
![](https://i.imgur.com/q8KwViR.png)

1. 92번 세그먼트에 대한 ACK이 TimeInterval 내에 도착하지 못하여 송신측(HostA)는 이를 재전송
2. 100번 세그먼트에 대한 ACK이 TimeInteval 내에 도착하지 못하여 송신측(HostA)는 이를 재전송 (할 예정)
3. 재전송한 92번 세그먼트에 대해 수신측(HostB) 수신 완료
4. 수신측(HostB)는 100번 세그먼트까지 잘 받았고, 이들이 재전송임을 알고 있음. ***다음 받아야 할 순서 번호***(=ACK)는 120이므로 ACK=120 전달

### 3️⃣
![](https://i.imgur.com/dtTh8Ng.png)

1. 92번 세그먼트에 대한 ACK이 TimeInterval 내에 도착하지 못하여 송신측(HostA)는 이를 재전송
2. 100번 세그먼트에 대한 ACK이 TimeInteval 내에 도착
3. 송신측(HostA)는 92번 세그먼트에 대한 ACK을 받지 못했지만 ACK=120에 의해 119번 바이트까지 모두 수신했음을 알기에 더 이상 재전송 X
## ACK
1. 순서가 맞는 세그먼트 도착 -> 다음 세그먼트를 500ms 까지 기다리며 순서에 맞는 다음 세그먼트가 있을 시 하나의 ACK 전송
2. 순서가 바뀐 세그먼트 도착 -> 즉시 ACK을 보냄
## 빠른 재전송
세그먼트 타이머가 만료되기 전에 손실 세그먼트를 재전송
![](https://i.imgur.com/obnXoAz.png)
## Flow Control
속도를 일치시키는 서비스

- **receive window** 유지 -> 가용 버퍼 공간이 얼마나 되는지 송신자에게 알려줌
### 사례
Host A가 Host B에게 큰 파일 전송

#### Host B
**RcvBuffer** : Host B의 수신 버퍼 크기
**LastByteRead** : 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트의 번호
**LastByteRcvd** : RcvBuffer에 저장된 데이터 스트림의 마지막 바이트 번호

$$LastByteRcvd - LastByteRead \le RcvBuffer$$
오버플로를 허용하지 않음
$$rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]$$
**rwnd** : 버퍼의 여유 공간 -> 동적
#### Host A
**LastByteSent** : 마지막으로 보낸 바이트의 번호
**LastByteAcked** : 마지막으로 정상 응답을 받은 바이트의 번호
전송 확인 응답이 안 된 데이터 양 = $LastByteSent - LastByteAcked$

$$LastByteSent - LastByteAcked \le rwnd$$
HostB가 오버플로우 되지 않음을 보장해야 함
#### 처리 방법
1. $rwnd = 0$이 됨
2. HostB(Receiver)가 HostA(Sender)가 보낸 데이터를 차단하고, rwnd가 0임을 TCP 헤더에 포함하여 보냄
3. HostA는 rwnd값을 확인한 후, 1바이트의 데이터를 지속해서 보냄
4. HostB의 receive window가 비워지면 ACK에 0이 아닌 rwnd값이 전해짐
## 핸드셰이킹
### 1️⃣ 3-way Handshaking
연결 수립 핸드셰이킹

![](https://i.imgur.com/01B3HmQ.png)
1. Client -> Server : 특별한 TCP 세그먼트 송신
	- 애플리케이션 계층 데이터 포함 X
	- SYN 비트 1로 설정
	- seq로 `client_isn` 순서 번호 주입
2. Server가 SYNACK 세그먼트 송신
	- Client의 세그먼트에서 SYN 비트 추출
	- SYN 비트 1로 설정
	- ACK은 `client_isn + 1`로 설정
	- seq은 `server_isn` 설정 
3. 클라이언트가 버퍼와 변수 할당
	- ACK에 `server_isn + 1` 설정
	- 연결이 설정되었으므로 SYN 비트 0으로 설정

>**SYN 플러드 공격**
>무수한 SYN 수신으로 반쪽짜리 연결을 수립하여 서버의 자원을 고갈시키는 DoS 공격 중 하나
>***SYN쿠키***를 통해 반쪽 연결을 수립하지 않고, 해시 번호를 만들어두었다가 SYNACK 세그먼트와 비교를 한 후, 연결 혹은 버림
### 2️⃣ 2-way handshaking
연결 종료 핸드셰이킹

![](https://i.imgur.com/rAU4TWX.png)
1. Client -> Server : FIN 비트 1로 설정된 TCP 세그먼트 송신
2. Server -> Client : 확인 응답 세그먼트 송신
3. Server -> Client : FIN 비트 1로 설정된 TCP 세그먼트 송신
4. Client -> Server : 확인 응답 세그먼트 송신
## Congestion Control
### 혼잡 원인, 비용
#### 1️⃣ 시나리오 1 : 2개의 송신자, 무한 버퍼 라우터
![](https://i.imgur.com/xvQsraL.png)

**Host A, B**
![](https://i.imgur.com/VTxTQpF.png)
- 2개의 송신자이므로 최대 라우터의 용량 R에서 각자 R/2만큼 사용 가능

**Host C, D**
![](https://i.imgur.com/RepmG2V.png)
- 2개의 송신자가 있으므로 항상 최대 R/2만큼 이용할 수 있음
- 링크 용량에 근접함에 따라 큐잉 지연이 지수적으로 커짐
#### 2️⃣ 시나리오 2 : 2개의 송신자, 유한 버퍼 라우터
![](https://i.imgur.com/Vj9pu1G.png)
vs 시나리오 1
- 버퍼가 가득 찼을 경우 도착하는 패킷은 버려짐
- 신뢰적 -> 패킷이 라우터에서 버려질 경우 재전송

1) Host A, B가 버퍼의 가용 공간을 알 수 있음 (비현실적)
	![](https://i.imgur.com/Tm3wdSQ.png)
	패킷이 어떠한 경우에도 손실되지 않음
2) 패킷이 확실히 손실될 경우에만 재전송 -> 큰 타임아웃
	![](https://i.imgur.com/BIemjVt.png)
	재전송되는 패킷 = $R/2 - R/3$ = $R/6$
3) 큐에서 지연되고 있는 패킷을 재전송
	![](https://i.imgur.com/YjRzxBE.png)
	원래의 패킷 + 재전송 패킷 모두 수신자에게 전달
	평균적으로 두 번에 한 번씩 재전송되기 때문에 처리량은 $R/4$
#### 3️⃣ 시나리오 3 : 4개의 송신자, 유한 버퍼 라우터, 멀티 홉
![](https://i.imgur.com/R2nY8ds.png)
**A -> C 연결**
- D -> B와 R1 공유
- B -> D와 R2 공유

A -> C 전송량이 낮아지면, R1에서 D -> B의 전송량이 커질 수 있음

> 💡 멀티홉에서 처리량의 트레이드가 일어남
## 혼잡 알림 방식
### 1️⃣ 종단 간의 혼잡 제어
- 네트워크 계층의 직접적인 지원 없음
- 종단 시스템이 혼잡을 추측
- TCP 세그먼트 손실을 기준으로 윈도 크기를 조절함
### 2️⃣ 네트워크 지원 혼잡 제어
![](https://i.imgur.com/AKUhxe6.png)
- 송신자, 수신자에게 직접적인 피드백 제공
- 라우터가 자신의 출력 링크 가용량을 송신자에게 명확히 알림
- 해당 알림을 받은 수신자는 이를 송신자에게 다시 알림 -> 왕복 시간 소요
## 전통적 Congestion Control
### 1️⃣ TCP 송신자는 트래픽 전송률을 어떻게 제한하는가?
- **Congestion Window** 추적
$$ LastByteSent - LastByteAcked \le min(cwnd, rwnd)$$

**자체 클로킹**
- 확인응답을 congestion window 크기 증가를 유발하는 트리거로 사용
- ACK이 빠른 속도로 온다면 congestion window는 빠르게 증가, ACK이 느린 속도로 온다면 congestion window는 느리게 증가
### 2️⃣ TCP 송신자가 수신자와 그 사이의 혼잡을 어떻게 감지하는가?
- 타임아웃
- 3개의 중복된 ACK 수신
### 3️⃣ 혼잡이 발생하였다면, 송신율 변화를 위해 어떤 알고리즘을 써야하는가?
![](https://i.imgur.com/Jjr7xq0.png)
#### 슬로 스타트
![](https://i.imgur.com/T8eNEoe.png)
cwnd를 1MSS에서 시작하여 ACK를 받을 때마다 MSS 만큼 증가
ssthresh(slow start threshold)의 값을 cwnd/2로 설정 (혼잡이 검출된 시점의 반절)
지수적으로 증가

**종료**
- 타임아웃으로 표시되는 손실 이벤트가 발생할 경우
	- cwnd를 1로 설정하고 새롭게 시작
- cwnd가 ssthresh에 도달하였을 때
	- ***혼잡 회피 모드*** 돌입
- 3개의 중복 ACK이 발견되었을 때
	- ***빠른 회복 상태*** 돌입
#### 혼잡 회피
혼잡 회피에 돌입했을 때 cwnd = 마지막으로 혼잡이 발견되었을 때 값의 반절
RTT마다 하나의 MSS만큼 증가

**종료**
- 타임아웃이 발생했을 때
	- 슬로 스타터와 같이 동작
	-  cwnd를 1로 설정
	- $ssthresh = cwnd / 2$
- ACK이 발생했을 때 -> 타임아웃과 다르게 송신자는 계속해서 ACK을 보내기 때문에 덜 과감해야함
	- cwnd를 cwnd / 2로 설정
	- ssthresh를 업데이트 한 cwnd / 2로 설정
	- ***빠른 회복 상태*** 돌입
#### 빠른 회복
- 모든 중복된 ACK에 대해 1MSS씩 증가

**종료**
- 타임아웃이 발생했을 때
	- cwnd를 1로 설정
	- $ssthresh = cwnd / 2$
	- 이후, 혼잡 회피로 전이

> 💡 TCP 혼잡 제어는 **AIMD** 혼잡 제어라고 불림
> **AIMD**
> ![[Pasted image 20240401224344.png]]
> - additive-increase, multiplicative decrease
> - RTT마다 1MSS 씩 cwnd의 선형 증가, 3개의 중복 ACK 이벤트에서 cwnd의 절반화

> **QUBIC**
> ![[Pasted image 20240401224815.png]]
> - AIMD는 혼잡 제어에서 너무나 조심스럽게 증가함
> - 세제곱함수로 증가 -> 이전 혼잡 시기와 가까울 땐 적게, 멀 땐 많이 증가
> - 정체 수준이 크게 변경된 경우 효과적
## 공평성
![](https://i.imgur.com/Wa7G59f.png)
#### 목표
두 개의 Connection이 있을 경우, 모두 1MSS 씩 cwnd가 증가하므로 45도 각도로 선형 증가하며 R에 도달할 것
R을 초과할 경우, 혼잡 회피와 빠른 회복을 통해 조정되며 결국 R에 수렴할 것

1. **A**
	- R보다 아래에 위치하므로 손실 발생 X
	- 1MSS씩 증가하므로 선형 증가
2. **B**
	- A에서 1MSS씩 증가하다가 손실 발생
	- 혼잡 회피, 빠른 복구로 cwnd를 감소시킴
3. **C**
	- B에서 알고리즘을 통해 각각 절반씩 cwnd가 감소함
4. **D**
	- B와 같은 현상 발생
=> 결국 R에 수렴