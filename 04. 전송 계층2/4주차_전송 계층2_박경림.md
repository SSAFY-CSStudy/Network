# 4️⃣ Network Layer

태그: 9주차, CSS

# 3.5 연결지향형 트랜스포트: TCP

- ‘핸드셰이크’ 먼저 하고 데이터 전송 가능 → `연결지향형(connection-oriented)`

## 3.5.1 TCP 연결

- 두 통신 종단 시스템의 TCP에 존재하는 상태를 공유하는 논리적인 것
- `전이중 서비스` 제공(full-duplex service: 데이터가 a→b 가능하다면, b→a도 가능)
- 항상 `점대점(point-to-point)` 연결이므로, 멀티캐스팅(일대다) 불가능
- `flow control`

## 3.5.2 TCP 세그먼트 구조

![Untitled](https://github.com/SSAFY-CSStudy/Network/assets/79007826/07ef078d-17ca-48de-b4a1-502df7e43805)

- ack #: 여기까지는 잘 받았다.
- byte stream
- receive window: flow control를 위해서 남은 공간을 알려줌

### 순서 번호와 확인응답 번호

sequence number

- byte stream이어서 segment 데이터의 첫 번째 바이트(숫자)

ack

- 상대로부터 기대하는 다음 바이트의 순서 번호

![Untitled 1](https://github.com/SSAFY-CSStudy/Network/assets/79007826/4362c7be-a68a-47e9-86ed-4b119a3206aa)

범위 밖 세그먼트를 어떻게 처리할지는

- os 구현에 따라 달라짐

### simple telnet scenario

![Untitled 2](https://github.com/SSAFY-CSStudy/Network/assets/79007826/0aa27446-c209-436f-aacc-6f5c7c1f4679)

piggybacking

- 돼지 등에 올라탄다.
- seq, ack, data 등 한꺼번에 보낸다.

## 3.5.3 왕복 시간(RTT) 예측과 타임아웃

TCP 타임아웃 값을 어떻게 설정?

- RTT보다 크게
- 너무 짧으면: 쓸데없는 타임아웃이 자주 발생
- 너무 크면: segment loss에 대한 reaction이 너무 느려짐

### 왕복 시간 예측

SampleRTT

- segment를 전송하고 ack을 받기까지
- 재전송 무시

Smoothing

- 평균을 낸다
- 수식
- EstimatedRTT = (1 - α) × EstimatedRTT + α × SampleRTT
(추천 α의 값: 0.125)

![Untitled 3](https://github.com/SSAFY-CSStudy/Network/assets/79007826/7f041764-6fcf-4c32-84aa-7320c57904f9)


- 실제로는 표준편차 값 도입
DevRTT = (1 - β) × DevRTT + β × | SampleRTT - EstimatedRTT |
(추천 β의 값: 0.25)

### 재전송 타임아웃 주기의 설정과 관리

→ 추천 타임아웃값: TimeoutInterval = EstimatedRTT + 4 × DevRTT

## 3.5.4 신뢰적인 데이터 전송

TCP rdt service 

- pipelined segments
- cumulative acks
- single retransmission timer (like go-back-n)

retransmission

- timeout events
- duplicated acks

### TCP sender events

data rcvd from app

- application data가 내려오면
- segment + seq # 만들기
- timer 시작
    - 타임아웃 interval

timeout

- 그 세그먼트 재전송
- 타이머 재시작

ack rcvd 

- update segment
- 아직 ack 못 받은 segment 있다면 타이머 재시작

### 몇 가지 흥미로운 시나리오

손실된 확인응답에 기인하는 재전송

![Untitled 4](https://github.com/SSAFY-CSStudy/Network/assets/79007826/cf47eef9-046c-4799-9c17-0b8399d0cb7c)

세그먼트 100이 재전송되지 않는 경우

![Untitled 5](https://github.com/SSAFY-CSStudy/Network/assets/79007826/a7a47579-e857-4798-8f38-77f8f2c148b4)

누적 확인응답 - 세그먼트 재전송 방지 

![Untitled 6](https://github.com/SSAFY-CSStudy/Network/assets/79007826/9be044ea-8b93-40bc-abff-15791b4bc2fa)

### TCP ACK 생성 권고[RFC 5681]

| 이벤트 | TCP 수신자 동작 |
| --- | --- |
| 기다리는 순서 번호를 가진 ‘순서가 맞는’ 세그먼트의 도착.
기다리는 순서 번호까지의 모든 데이터는 이미 확인응답된다. | 지연된 ACK. 
또 다른 ‘순서가 맞는’ 세그먼트의 도착을 위해 500 ms까지 기다린다. 
만약 다음 ‘순서에 맞는’ 세그먼트가 이 기간에 도착하지 않으면, 그냥 ACK를 보낸다. |
| 기다리는 순서 번호를 가진 ‘순서가 맞는’ 세그먼트의 도착.
ACK 전송을 기다리는 다른 하나의 ‘순서에 맞는’ 세그먼트가 있다. | 2개의 ‘순서가 맞는’ 세그먼트들을 ACK하기 위해, 하나의 누적된 ACK를 즉시 보낸다. |
| 기다리는 것보다 높은 순서 번호를 가진 ‘순서가 바뀐’ 세그먼트의 도착. 
격가 발견된다. | 순서 번호가 다음의 기다리는 바이트(즉, 격차의 최솟값)를 나타내는 중복 ACK를 즉시 보낸다. |
| 수신 데이터에서 격차를 부분적으로 또는 모두 채우는 세그먼트의 도착. | 그 세그먼트가 격차의 최솟값에서 시작한다고 하면, 즉시 ACK를 보낸다. |

### 빠른 재전송

이전까지는 timeout시 재전송
timout 기다리지 말고 기다리길 원하는 패킷(triple duplicate acks) 전송

![Untitled 7](https://github.com/SSAFY-CSStudy/Network/assets/79007826/529e7690-41f8-4992-8738-95b1572a7e5a)

→ retransmit은 timeout or triple duplicate acks에 의해 발생

## 3.5.5 흐름 제어

receiver 컴퓨터가 너무 느리다면? 문제

receiver가 감당할 수 없을 정도의 속도로 보내는 것을 조절하는 것이 flow control 

![Untitled 8](https://github.com/SSAFY-CSStudy/Network/assets/79007826/cb927ccf-4e9c-42b4-aeb4-9aba3a5a3561)

rwnd(receive window) 변수를 이용하여 flow control한다.

## 3.5.6 TCP 연결 관리

**2 way handshake 실패 시나리오**

![Untitled 9](https://github.com/SSAFY-CSStudy/Network/assets/79007826/99a9b58e-af43-4045-8643-ea2695e9904a)

- connection이 끊긴 상태에서 새로운 요청이 오면…?

새로운 connection인지 기존 connection인지 구분이 안 되는 문제

**3 way handshake**

![Untitled 10](https://github.com/SSAFY-CSStudy/Network/assets/79007826/c26b78f8-12ff-451a-9686-0f4068a1e428)

- syn, ack 설정하여 sync(seq #)가 되었는지 안 되었는지 구별

2 way handshake 문제 해결

첫 syn은 random 값 

**FSM**

![Untitled 11](https://github.com/SSAFY-CSStudy/Network/assets/79007826/65fa0f55-912e-4ce2-b05e-6ce169d23930)

![Untitled 12](https://github.com/SSAFY-CSStudy/Network/assets/79007826/d556e621-7e6c-45d1-a965-551b24d7e95b)

**closing a connection**

1. client FIN 보냄 → FIN with ACK 보냄 server
2. 그 반대 과정도 하고
3. time wait → closed!!!

![Untitled 13](https://github.com/SSAFY-CSStudy/Network/assets/79007826/1753dc5e-225f-49ee-8d7a-234f0aaa60e1)

## 3.6 혼잡 제어의 원리

혼잡: 네트워크가 감당할 수 없을만큼 많은 데이터를 너무 빨리 보내는 것 

manifestations

- lost packets (buffer overflow at routers)
- long delays (queueing in router buffers)

### 3.6.1 혼잡의 원인과 비용

**시나리오1: 2개의 송신자와 무한 버퍼를 갖는 하나의 라우터**

packet loss x, no retransmission, fair share 

![Untitled 14](https://github.com/SSAFY-CSStudy/Network/assets/79007826/e33e816d-4699-4d3c-8b5d-937bd141f78f)

![Untitled 15](https://github.com/SSAFY-CSStudy/Network/assets/79007826/2dc60090-fc01-45e4-9dc8-b32394980600)

![Untitled 16](https://github.com/SSAFY-CSStudy/Network/assets/79007826/dafd4082-6522-415b-a0f2-b01ec9363e35)

**시나리오2: 2개의 송신자, 유한 버퍼를 가진 하나의 라우터**

packet loss o, retransmission

![Untitled 17](https://github.com/SSAFY-CSStudy/Network/assets/79007826/c23fd92a-7940-40d6-bc65-27324169d44b)

![Untitled 18](https://github.com/SSAFY-CSStudy/Network/assets/79007826/017a0507-5180-493d-884f-9a50605d4a88)

application-layer input = application-layer output

transport-layer input(retransmission) ≥ application-layer output

1. 버퍼 공간이 있을 때만 
2. 패킷 loss를 알고 그 패킷만 보냄 (이상적), R/2에 수렴 / 중복 패킷(현실) 

**시나리오3: 4개의 송신자와 유한 버퍼를 갖는 라우터, 그리고 멀티홉 경로** 

![Untitled 19](https://github.com/SSAFY-CSStudy/Network/assets/79007826/e655e5dd-9afa-4c1c-b9d1-f815d1b24106)

![Untitled 20](https://github.com/SSAFY-CSStudy/Network/assets/79007826/8a2588ce-03f9-4fe2-8c65-a27e14372b30)

버퍼가 꽉 차면 loss 발생, 한 connection(가까이 있는 놈)이 버퍼를 독점할 수도…  

그러면 throughput이 모두가 0, congestion collapse (인터넷 초창기) 

→ congestion control 반드시 필요하다! 

### 3.6.2 혼잡 제어에 대한 접근법

`window size`: ack을 받지 않고 보낼 수 있는 최대 size, 클수록 속도가 빠르다
1이면 stop-and-wait
→ 이걸 조절함으로써 congestion control 

addictive increase: 매 RTT마다 cwnd 증가 (1 MSS(maximum segment size)), loss 탐지하기 전까지 (조심스럽게 증가)

multiplicatvie decrease: loss detected 이후 cwnd 절반으로 줄임 (확 감소) 

- sender: LastByteSent - LastByteAcked ≤ cwnd
- TCP sending rate ~~ cwnd / RTT bytes/sec

**슬로 스타트**

첫 cwnd = 1 MSS 이후 exponentially 증가 

**detecting, reacting to loss**

timout 발생 (loss!)

- cwnd를 1 MSS (slow start)
- window then grows exponentially to threshold, 이후 선형 증가

**switching from slow start to CA**

- loss 후 thresshold는 절반으로 줄임

![Untitled 21](https://github.com/SSAFY-CSStudy/Network/assets/79007826/924e72e4-5eb6-4764-9ecf-c170ac5b0ab3)

**혼잡 제어 그래프**

![Untitled 22](https://github.com/SSAFY-CSStudy/Network/assets/79007826/35ec2f1f-d93e-4780-8f1b-2823e6efc334)

1. TCP는 3개의 중복 ACK 이벤트가 발생할 때까지 **선형으로 그 혼잡 윈도 크기(결국 전송률)를 증가시킨다.**
2. 그러고 나서는 혼잡 윈도 크기를 **감소**시키지만,
3. 다시 추가적인 가용 대역폭이 있는지를 탐색하기 위해 **선형으로 증가**시키기 시작한다.

**TCP throughput**

…

**TCP Fairness**

K개의 TCP 세션이 같은 bankdwidth R인 bottleneck link를 공유할 때, R/K 평균 속도를 가져야 한다. 

- 실제로 fair한가?

additive increase, multiplicative decrease가 반복적으로 일어나다보면 R/K가 됨, fair하다.

- RTT가 다르면?

RTT가 짧은 놈이 높은 throughput 

- 뛰는 횟수가 다르면? (아마 router나 hub?)

조금 더 낮은 throughput 갖는 게 맞다.

**Fairness and UDP**

- rate control 전혀 안 함

**Fairness, parallel TCP connections**

- parallel connection

속도 더 빠르다고 느끼게 

### 3.7.2 네트워크 지원 명시적 혼잡 알림

**명시적 혼잡 알림**

1. two bit field를 헤더에 추가 
network 안에서 congestion이 얼마나 심했는지 알려주는 역할
2. 패킷이 어느 정도 차오르면 random early drop해서 congestion 제어
