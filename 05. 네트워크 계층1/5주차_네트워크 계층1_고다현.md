# 4. 네트워크 계층: The Data Plane

## 1. 네트워크 계층 개요

![Untitled](https://github.com/SSAFY-CSStudy/Network/assets/101400650/8ea21344-9ebd-4230-a842-e4ffdfb13f29)

- 두 호스트 H1과 H2가 있을 때, 네트워크 계층은 두 호스트 중 하나의 트랜스포트 계층 세그먼트를 추출하여 H2의 트랜스포트 계층까지 전달하는 역할
- `데이터 평면` : 입력 링크에서 출력 링크로 데이터그램을 전달한다.
- `제어 평면` : 데이터그램이 출발지 호스트에서 목적지 호스트까지 전달되게끔 로컬 포워딩, 라우터별 포워딩을 대응시킨다.

### 1. 포워딩과 라우팅 : 데이터 평면과 제어 평면

네트워크 계층의 역할 : 송신 호스트에서 수신 호스트로 패킷을 전달하는 것

- forwarding(전달)
    - 패킷이 라우터의 입력 링크에 도달했을 때 라우터는 그 패킷을 적절한 출력 링크로 이동시켜야함
    - 포워팅에서 예외적으로 한 기능은 데이터 평면에서 실행
    - 매우 짧은 시간 단위를 갖기에 대표적으로 하드웨어에서 실행된다.
- routing
    - 송신자가 수신자에게 패킷을 전송할 때, 네트워크 계층은 패킷 경로를 결정해야 함
    → 경로 계산 알고리즘 : 라우팅 알고리즘
    - 네트워크 전반에 걸쳐 출발지에서 목적지까지 데이터 그램의 종단 경로를 결정하여 시간이 오래걸려 소프트웨어에서 실
    

**포워딩 테이블**

![Untitled 1](https://github.com/SSAFY-CSStudy/Network/assets/101400650/ebb68966-ca0e-461b-b7a5-6dba21fa96d4)

라우터는 도착하는 **패킷 헤더의 필드값**을 통해 **`포워딩 테이블`의 내부 색인으로 사용하여 패킷을 전달**한다.

포워딩 테이블 엔트리에 **저장되어 있는 헤더의 값은 해당 패킷이 전달되어야 할 라우터의 외부 링크 인터페이스**를 나타낸다.

**제어평면**

- SDN 접근 방법
    
    ![Untitled 2](https://github.com/SSAFY-CSStudy/Network/assets/101400650/fcd54885-3eb9-4f97-8607-644efc833ef2)


    라우터로부터 물리적으로 분리된 원격 컨트롤러 컴퓨터와 각각의 라우터에 의해 사용될 포워딩 테이블을 분배하는 다른 접근법을 보여준다.
    
    라우터는 원격 컨트롤러와 포워딩 테이블과 그 밖의 라우팅 정보를 포함한 메시지를 교환함으로써 소통한다.
    
    **원격 컨트롤러가 포워딩 테이블을 계산 및 배분하는 동안 라우팅 기기는 포워딩만을 수행**한다.
    
    즉, 네트워크가 **소프트웨어적으로 정의되었을 때** `포워딩 테이블`을 계산하는 **컨트롤러는 라우터와 상호작용을 하며 소프트웨어에서 실행**된다.
    
    이렇게 원격 컨트롤러가 라우터와 떨어져서 높은 신뢰성과 중복성을 갖춘 원격 데이터 센터에 위치하는 접근 방법은 `SDN(software defined networking)`의 중심이다.
    

### 2. 네트워크 서비스 모델

네트워크 계층 제공 서비스

- `보장된 전달`: 패킷이 출발지 호스트에서부터 목적지 호스트까지 도착 보장
- `지연 제한 이내의 보장된 전달`: 패킷의 전달을 보장할 뿐만 아니라 호스트 간의 특정 지연 제한(예: 100ms 이내) 안에 전달
- `순서화 패킷 전달`: 패킷이 목적지에 송신된 순서대로 도착 보장
- `최소 대역폭 보장`: 송신과 수신 호스트 사이에 특정한 비트율의 전송 링크를 에뮬레이트한다. 송신 호스트가 비트들을 특정한 비트율 이하로 전송하는 한, 모든 패킷이 목적지 호스트까지 전달된다.
- `보안 서비스`: 네트워크 계층은 모든 데이터 그램을 출발지 호스트에서는 암호화, 목적지 호스트에서는 복호화할 수 있게 하여 트랜스포트 계층의 모든 세그먼트에 대해 기밀성을 유지해야한다.

## 2. 라우터 내부에는 무엇이 있을까?

![Untitled 3](https://github.com/SSAFY-CSStudy/Network/assets/101400650/85e46e6e-18fc-43c4-866f-b3d3c6c41bff)

- 입력 포트
    - 입력 포트의 **맨 왼쪽과 맨 오르쪽 박스는 라우터로 들어오는 입력 링크로, 물리 계층 기능을 수행**
    - 입력 포트의 가장 오른쪽에서 수행되는 **검색 기능
    → 포워딩 테이블을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트 결정**
    - 라우팅 프로토콜 정보를 전달하는 패킷인 `제어 패킷`은 입력 포트에서 라우팅 프로세서로 전달
- 스위치 구조
    - 스위치 구조는 라우터의 입력 포트와 출력 포트를 연결
    - 라우터 내부에 포함
- 출력 포트
    - **스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷을 전송**
- 라우팅 프로세서
    - 제어평면 기능 수행
    - 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산
    

### 1. 입력 포트 처리 및 목적지 기반 전송

![Untitled 4](https://github.com/SSAFY-CSStudy/Network/assets/101400650/84ffde98-88da-44c7-a0d2-ec44e1c6be61)

- line termination : physical layer,  bit-level
- link layer protocol : data link layer
- lookup, forwarding queueing
    - 라우터는 포워딩 테이블을 사용하여 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색한다.
    - 포워딩 테이블은 라우팅 프로세서에서 계산되거나 갱신되거나 원격 SDN 컨트롤러에서 수신된다.
    - 포워딩 테이블은 라우팅 프로세서에서 맨위 그림과 같이 각 라인 카드로 복사되고, 이렇게 각 라인이 복사본을 사용하여 패킷 단위로 중앙 집중식 라우팅 프로세서를 호출하지 않게 되어 병목 현상을 피할 수 있다.
    

**목적지 주소 범위 포워딩 테이블**

![Untitled 5](https://github.com/SSAFY-CSStudy/Network/assets/101400650/b848b242-a478-4d62-a106-5decb1290d37)

라우터에서 0에서 3까지의 4개의 링크가 있다고 가정

→ 범위가 잘 주어지지 않을 경우

**프리 픽스 포워딩 테이블**

![Untitled 6](https://github.com/SSAFY-CSStudy/Network/assets/101400650/e8e2e06d-bda6-4593-9657-4c7464ac291c)

예를 들어, 패킷의 목적지 주소가 `11001000 00010111 00010110 10100001` 라면 앞 21개의 비트 프리픽스가 테이블의 첫 번째 엔트리와 매치되므로 라우터는 이 패킷을 링크 인터페이스 0으로 보낸다.

`11001000 00010111 00011000 10101010`와 같이 처음 24비트는 2번째에 처음 21비트는 3번째에 매치되는 경우 라우터는 `최장 프리픽스 매치 규칙(longest prefix matching rule)`을 사용한다.

→ 테이블에서 가장 긴 매치 엔트리를 찾고, 여기에 연관된 링크 인터페이스로 패킷을 보낸다

**longest prefix matching**

- 메모리 접속 시간에 특별한 주의를 기울여야하므로 내장형 DRAM과 빠른 SRAM 메모리가 있는 설계가 필요하다. 
→ TCAM도 검색을 위해 자주 사용
- 검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위치 구조로 보낼 수 있다. 일부 설계에서는 다른 입력 포트로부터 패킷이 현재 구조를 사용하고 있다면 패킷이 스위칭 구조에 들어가는 것을 일시적으로 차단할 수 있다.

### 2. 스위칭

![Untitled 7](https://github.com/SSAFY-CSStudy/Network/assets/101400650/110d2182-64b1-4340-bb47-b603080ab46a)

패킷 전달 과정

1. 패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사한다.
2. 라우팅 프로세서는 헤더에서 목적지 주소를 추출한다.
3. 포워딩 테이블에서 적절한 출력 포트를 찾은 다음 패킷을 출력 포트의 버퍼에 복사한다.

**버스를 통한 교환**

![Untitled 8](https://github.com/SSAFY-CSStudy/Network/assets/101400650/76b7b9d2-22bc-4e1c-9326-81fab2151bec)

- 입력 포트는 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다.
- bus contention : switching speed는 bus bandwidth로 제한된다.
    
    → 모든 패킷이 하나의 버스를 통과해야함
    

**상호 연결 네트워크를 통한 교환**

![Untitled 9](https://github.com/SSAFY-CSStudy/Network/assets/101400650/19795ea5-b590-43da-bbe7-2351fd1a5682)

- bus bandwidth의 한계를 극복함
- 크로스바 스위치는 N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호연결 네트워크다.
- 각 수직 버스는 교차점에서 각 수평 버스와 교차하며 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있다.
    
    → 앞의 두가지 방식과 달리 크로스바 스위치는 여러 패킷을 병렬로 전달할 수 있다.
    
- 그러나 두개의 서로 다른 입력 포트에서 나오는 2개의 패킷이 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야한다.
- 좀 더 정교한 상호연결 네트워크는 다단계 스위치 구조를 통해 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 향해 동시에 전달할 수 있도록 여러 단계의 스위칭 요소를 사용한다.

### 3. 출력 포트 처리

**입력 큐잉**

- 지연 없이 구조를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 충분히 빠르지 않으면 어떻게 될까?
→ 이 경우에는 패킷이 스위치 구조를 통해 출력 포트로 전송되기 위해 차례를 기다려야한다.
- 이 큐잉의 결과를 살펴보기 위해 크로스바 스위치 구조를 가정해보자.
    1. 모든 링크의 속도는 같다.
    2. 입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달한다.
    3. FCFS (First-Come-First-Served) 방식으로 패킷은 입력 큐에서 출력 큐로 이동된다.

출력 포트가 다르다면 여러 패킷이 병렬로 전달 가능하지만, 같다면 하나의 패킷만 지정된 출력 포트로 전송이 가능하고 나머지 패킷은 기다려야한다.

![Untitled 10](https://github.com/SSAFY-CSStudy/Network/assets/101400650/07fab92e-b94e-410e-9796-2597f1ca013d)

- `HOL(Head-of-the-line) 차단` : 하단 큐의 가장 앞쪽의 패킷은 출력 포트가 같으므로 대기하여야하고, 두번째 패킷은 출력 포트가 다름에도 앞의 패킷 때문에 대기하여야한다.
    - 해결방법
        - FIFO queueing을 버려야함 → Virtual Output Queue

**Output ports**

![Untitled 11](https://github.com/SSAFY-CSStudy/Network/assets/101400650/149cc309-4f02-4db7-ae5a-095f90c0ce8d)

출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송한다. 여기에는 전송을 위한 패킷 선택 및 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능을 수행하는 것이 포함된다.

- buffering은 datagram이 fabric에 전송 속도보다 빨리 도착할 경우

![Untitled 12](https://github.com/SSAFY-CSStudy/Network/assets/101400650/57fbfee1-e479-483c-b975-fd40d2a34b70)

입력 포트와 출력 포트의 개수가 각각 N개이고 속도가 R이라 할 때, 스위치의 속도가 R보다 N배 빠르고 모든 입력 포트의 패킷이 동일한 출력 포트로 향한다고 가정해보자.

이 경우, 출력 링크에서 단일 패킷을 보내는 데 걸리는 시간에 N개의 새로운 패킷이 출력 포트에 도착한다. 출력 포트는 **시간 단위에 단일 패킷만을 전송할 수 있기 때문에 N개의 도착 패킷은 출력 링크를 통한 전송 큐에서 대기** 해야한다.

이때 큐의 공간이 충분하지 않을 때, 즉 **메모리가 충분하지 않을 때 도착한 패킷을 삭제하고나 이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간을 확보**해야 한다.

**얼마나 많은 버퍼가 요구되는가?**

몇년 동안 RFC의 버퍼의 크기에 대한 규칙은 링크 용량이 C일 때, 버퍼링의 양은 평균 왕복 시간(RTT)와 같아야 한다는 것이다.

즉, `B = RTT x C` 와 같은 버퍼의 양이 필요하다.

최근의 실험과 이론에서는 많은 수의 독립적인 TCP 흐름 N이 링크를 통과할 때, 필요한 버퍼링은 `B = RTT x C / √N` 이라고 제안하고 있다.

### 5. 패킷 스케줄링

- **FIFO**
    
    ![Untitled 13](https://github.com/SSAFY-CSStudy/Network/assets/101400650/0ba62978-7c67-44f7-8815-d8b6f8d62e56)

    ![Untitled 14](https://github.com/SSAFY-CSStudy/Network/assets/101400650/db1c67d2-044f-4128-9af9-8f5ddf567aaf)


- **라운드 로빈과 WFQ**
    - **라운드 로빈 큐잉 규칙** : 패킷은 우선순위 큐잉과 같이 클래스로 분류되지만 클래스 간에는 엄격한 서비스 우선순위가 존재하지 않으며, 라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아서 제공한다.
        - `작업 보존 큐잉` 규칙의 경우 전송을 위해 큐에서 기다리는 패킷이 있다면 링크는 유휴 상태가 되는 것을 허용하지 않는다.
        
        ![Untitled 15](https://github.com/SSAFY-CSStudy/Network/assets/101400650/ddfb051a-01a1-4142-93d7-34b9ceb92f72)

    - `WFQ(Weighted Fair Queueing) 규칙`
        - 도착하는 패킷은 적절한 클래스별 대기 영역에서 분류되며 대기
        
        ![Untitled 16](https://github.com/SSAFY-CSStudy/Network/assets/101400650/8e5bf4d8-60c3-4767-bc8a-ad3c300ca5ac)


## 3. 인터넷 프로토콜(IP) : IPv4, 주소체계, IPv6

### 1. IPv4 데이터그램 포맷
![Untitled 17](https://github.com/SSAFY-CSStudy/Network/assets/101400650/972c9c41-3037-4e47-9965-3fbdee47085a)
