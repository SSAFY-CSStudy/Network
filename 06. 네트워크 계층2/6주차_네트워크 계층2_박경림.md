# 6️⃣ Network Layer

태그: 11주차, CSS

# IP: Internet Protocol

## IP fragmentation, reassembly

?

## IPv4 addressing

- IP address: 32 bit identifier for host, router `interface` (에 할당)
- interface: host, router 사이 connection 제공
    - router: 여러 개 interface 갖고 있음
    - host: 하나 or 두 개

![Untitled](https://github.com/SSAFY-CSStudy/Network/assets/79007826/c2aae27f-2c0a-49f8-9649-692f3d7bb88b)

- 첫 24비트는 고정 (→ subnet)

### Subnets

- IP 주소 상 고정된 부분(subnet part)이 같은 host들의 모음
    - 그 외: host part
- 보통 24 bit → 그래서 host 주소 개수는 2^8 - 2(0서브넷 마스크, 1브로드캐스트 제외)

### CIDR

- Classless InterDomain Routing
- subnet part가 정해지지 않음
- a.b.c.d/x
- Class A, B, C, D, E 주소 체계 비효율적

### How to get one?

- 윈도우: 제어판 설정 → tcp/ip → properties …

### DHCP: Dynamic Host Configuration Protocol

- 내가 가입한 인터넷 사업자(ISP)로부터 자동으로 얻는 것(예: 가정 집)
- 컴퓨터 꺼져 있을 때도 IP 주소를 holding하는 건 비효율적
- 재사용 가능

**scenario**

1. host broadcasts DHCP discover msg
2. DHCP server responds DHCP offer (broadcasting)
3. host requests IP address (broadcasting)
4. server sends IP address (broadcasting)
- udp

### Hierarchical addressing: route aggregation

- subnet mask까지만 보고 interface로 routing
- ip 주소를 정확히 matching x

### How does an ISP get block of addresses?

ICANN: Internet Corporation for Assigned Names and Numbers

- allocates addresses
- manages DNS
- assigns domain names, resolves disputes

## NAT: network address translation

- IP 주소는 hierarchical한 것과 관련 있다.
- IP 주소를 효율적으로 사용할 수 있게
- security 이점 (특정 network 공격하기 힘듦)

**must**

- outgoing datagrams: (NAT IP address, new port #)
- remember in NAT translation table: (source IP address, port #) - (NAT IP address, new port #) 매핑
- incoming datagrams

**과정**

→ 책 보고 추가

controversial

## IPv6

2^32 = 42억 → 부족

processing, forwarding 스피드 향상

header 길이 고정

### datagram format

![Untitled 1](https://github.com/SSAFY-CSStudy/Network/assets/79007826/b9a267d3-a197-49fa-ab0d-e7b1913ae1f1)

- 128 bits
- checksum 없어짐
- options header 밖으로
- ICMPv6

### Transition from IPv4 to IPv6

IPv4 tunnel connecting IPv6 routers

서서히 변화 

# Generalized Forwarding and SDN

- flow table: forwarding table의 확장
- headers counters actions

## OpenFlow data plane abstraction

- actions: for matched packet: drop, forward, modify, matched packet or send matched packet to controller
- counters: #bytes and #packets
- 예시

```java
src=1.2.*.*, dest=3.4.5.* -> drop
src=*.*.*.*, dest 3.4.*.* -> forward(2)
src=10.1.2.3, dest=*.*.*.* -> send to controller?
```

## OpenFlow: Flow Table Entries

![Untitled 2](https://github.com/SSAFY-CSStudy/Network/assets/79007826/05d48b5e-981b-4872-8600-55f842b0fa72)

- Rule: 값을 보고 matching

![Untitled 3](https://github.com/SSAFY-CSStudy/Network/assets/79007826/e7ddae09-b1bc-4aca-8dfd-e710afba8829)

- 22번 막아라?

## OpenFlow abstraction

- match + action: unifies different kinds of devices

Router

- match: longest destination IP prefix
- action: forward out a link

Switch (L2)

- match: destination MAC address
- action: forward or flood

Firewall

- match: IP addresses and TCP/UDP port numbers
- action: permit or deny

NAT

- match: IP address and port
- action: modify? address and port

# Network layer control plane

data plane은 forwarding (hw 쪽)

control plane은 routing (hw가 어떻게 동작할지 결정하는 것)

- per-router control (traditional)
- logically centralized control plane(sdn concept): routing table update가 훨씬 쉬움

# Routing protocols

src → dest 좋은 경로 선택!

- 데이크스트라, 벨만-포드 등등
- least cost, fastest, least congested, hop 수

### Graph abstracion: costs

edge weight

### Routing algorithm classification

- global or decentralized
- static or dynamic

## link state

- global

### Dijkstra’s algorithm

뭔지 알지?

- O(nlogn)
- oscillations possible (문제점)

## distance vector

- not global

### Bellman-Ford equation (dynamic programming)

- dx(y): cost of least-cost path from x to y
- dx(y) = min { c(x, y) + dv(y) } (cost to neighbor v + cost from neighbor v to destination)

![Untitled 4](https://github.com/SSAFY-CSStudy/Network/assets/79007826/4a0bce4c-b3bb-46c4-a900-01a01905a175)

- key idea: 업데이트가 일어나야 하는 상황에서 distance vector를 이웃한테 보낸다
- iterative, asynchronous
- distributed

![Untitled 5](https://github.com/SSAFY-CSStudy/Network/assets/79007826/f09c7a90-8441-4659-a037-1f76f0344d9f)

### link cost changes

- detected하면
    - 우선 자기 테이블 update하고 neighbor들에게 알림
- 4 → 60?
    
    ![Untitled 6](https://github.com/SSAFY-CSStudy/Network/assets/79007826/57999e5f-b068-4840-a616-0a6b83586573)

    - Dy(x) = min { C(y, x) + Dx(x), C(y, z) + Dz(x) }
        
        = min { 60 + 0, 1 + 5 } = 6 → y가 z에게 알림
        
    - Dz(x) = min { C(z, y) + Dy(x), C(z, x) + Dx(x) }
        
        = min { **1 + 6**, 50 + 0 } = 7 → z가 y에게 알림
        
    - 계속 반복 (51까지 가면 더 이상 update x)
- poisoned reverse
    - z → y: x로 가는 길은 무한이다
    - 그러면 y가 z를 통해 x를 forwarding할 일이 없다

### LS vs DV

|  | Link State | Distance Vector |
| --- | --- | --- |
| message complexity | O(nE) | 이웃들만 주고 받음 |
| speed of convergence | O(n^2), 
oscillations  | count-to-infinity problem |
| robustness (router 오작동) | 한 놈만 잘못됨 | 이웃들에게도 전파 
→ 네트워크 전체로 propagation |
