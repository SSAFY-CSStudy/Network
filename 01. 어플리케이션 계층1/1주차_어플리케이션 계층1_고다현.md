# 2. application layer

## 1. 애플리케이션 계층


- 최상위 계층으로 사용자 또는 애플리케이션이 네트워크에 접속 할 수 있게 해주는 계층
- 애플리케이션은 네트워크를 통해 데이터를 통신해야함
- 이 계층에 속한 프로토콜 : HTTP, SMTP, SSH, DNS 등..

![Untitled](https://github.com/SSAFY-CSStudy/Network/assets/101400650/db1d1c6e-0c94-42f9-97d7-f191b461e167)

## 2. 네트워크 애플리케이션의 구조


### 1) Client-Server 와 P2P

- Client-Server 구조
    - server
        - listen 상태로 항상 켜져 있는 상태
        - 고정 IP 주소를 갖는다
        - server는 스케일링을 위해 여러 개의 데이터 센터를 운영
    - client
        - 가끔 혹은 향상 겨져 있을 수 있으며, 다중에 client가 server에게 요청할 수 있다
        - client는 서로 직접 소통하지 않는다
        - ex) 웹, 파일 전송, 원격 로그인, 전자 메일 등..
- Peer to Peer
    - 특정 서버를 통하지 않고, peer라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신한다. 피어들은 서비스 제공자가 소유하지 않고 대신에 사용자들이 제어하는 데스크톱과 랩톱이 소유한다. 대부분의 피어들은 가정, 대학, 사무실에 존재한다.
    - 이들은 일반적으로 상당한 서버 기반구조와 서버 대역폭을 요구하지 않는다. 비용이 싸다.
    - ex) 비트토렌트, 스카이프 등이 있음

![Untitled 1](https://github.com/SSAFY-CSStudy/Network/assets/101400650/f268692a-5c85-4fdf-a43c-48a880197733)

### 2) Socket

- 프로세스는 socket을 통해 네트워크로 메세지를 보내고 받는다.
- 애플리케이션 계층과 트랜스포트 계층 간의 인터페이
- 소켓 인터페이스의 주소를 정확하게 알아야 통신 가능 
→ 주소 결정 :  IP주소와 port 번호

![Untitled 2](https://github.com/SSAFY-CSStudy/Network/assets/101400650/43c182d9-8c46-4e83-9c5b-cca78839be68)

- Application Layer에서 Transport Layer에게 요구하는 요소
    - **Data Integrity (무결성)**
        - 특정 앱(file transfer, web transactions)는 데이터 전송에서 100% 신뢰성을 보장해야 한다
        - 특정 앱(audio)은 data loss가 가능
    - **Timing (타이밍)**
        - 특정 앱(internets , telephony, interactive games)들은 낮은 delay에서도 효과적으로 동작해야함
    - **Throughput (처리량)**
        - 특정 앱(multimedia)은 효율적인 최소 처리량을 요구
        - 특정 앱(elastic)은 그들이 얻는 처리량을 이용
    - **Security**
        - encryption, data integrity
            ![Untitled 3](https://github.com/SSAFY-CSStudy/Network/assets/101400650/9a2d405a-d6e9-4a68-975e-0b2f1d765070)


### 3) TCP vs UDP

- **TCP (Transmission Control Protocol)**
    - 연결 지향적 프로토콜 : Client와 Server가 연결된 상태에서 데이터를 주고 받는 프로토콜
    - 신뢰성을 보장하는 연결형 서비스
    - 특징
        1. 연결형 서비스로 가상 회선 방식 사용
            1. 3-way handshaking으로 연결 설정
            2. 4-way handshaking으로 연결 해제
        2. 흐름 제어(Flow control) 
        : 데이터 처리 속도를 조절하여 수진자의 버퍼 오버플로우 방지
        3. 혼잡 제어(Congestion control)
        : 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지
        4. 높은 신뢰성 보장 
        : 신뢰성 높은 전송을 하기 때문에, UDP 보다 속도가 느림
        
        5. 전이중(Full-Duplex), 점대점(Point to Point) 방식
        
        - 전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
        - 점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다
- **UDP(User Datagram Protocol)**
    - 비연결형 프로토콜
    → 연결을 위해 할당되는 논리적인 경로가 없고, 각각의 패킷은 다른 경로로 전송되며, 독립적인 관계를 지닌다.
    - 특징
        
        1. 비연결형 서비스로 데이터그램 방식을 제공 
        
        - 데이터의 전송 순서가 바뀔 수 있다.
        
        2. 데이터 수신 여부를 확인하지 않는다.
        
        - TCP의 3-way handshaking과 같은 과정 X
        
        3. 신뢰성이 낮다.
        
        - 흐름 제어(flow control)가 없어서 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
        
        4. TCP보다 속도가 빠르다.
        
        5. 1:1 & 1:N & N:N 통신이 가능하다.
        
    

## 3. HTTP(HyperText Transfer Protocol)

- 웹 통신 프로토콜로, 다른 오브젝트에 대한 링크가 있는 텍스트를 전송하는 프로토콜
- **Client-Server 구조**
- **TCP 사용**
- **stateless(무상태 지향)**
    - Server가 Client의 상태를 가지고 있지 않음
    - 상태를 유지해야하는 경우, 쿠키나 세션을 통해 해결함(로그인 등)

### **HTTP connections**

- **non-persistent HTTP(비지속 연결)**
    - 데이터를 주고 받을때마다 TCP 연결 관계를 끊었다가 다시 연결하는 형태
    - 과정
        1. HTTP 클라이언트는 기본 포트 80과 서버 IP의 주소를 이용해 TCP 연결 시도
        2. HTTP 클라이언트는 TCP 연결 소켓을 통해 HTTP 요청 메세지를 보낸다
        3. HTTP 서버는 TCP에게 TCP 연결을 끊으라고 한다
        4. HTTP 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단된다.
    - **RTT** : 패킷이(3-way handshake) client로 부터 Server 까지 갔다가 다시 Client로 되돌아 오는 시간
        - TCP 연결을 시도할 때 → 3-way handshake 발생
        - 세번째 부분에서 클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내며 응답을 함께 보낸다.
        - 일단 요청 메시지가 서버에 도착하면 서버는 HTML 파일을 TCP 연결로 보낸다.
        - HTTP 요청/응답 총 시간 : 2RTT + HTML 파일로 서버가 전송하는데 걸리는 시간
        
        ![Untitled 4](https://github.com/SSAFY-CSStudy/Network/assets/101400650/e8a8b922-e122-4b31-b384-7a38d4a10bf5)

    - 장점
        - 한정된 서버 자원을 효율적으로 쓸 수 있음.
        - 클라이언트에게 할당되었던 자원을 끊음으로서 재사용 가능.
    - 단점
        - 연결을 새로 맺음으로 인해 같은 클라이언트와 재 통신 시 시간 증가(연결시간)
- **persistent HTTP(연결)**
    - TCP 연결을 이어서 사용하는 형태
    - Client의 요청들을 다 응답해주기 전에 연결을 이어서 사용하여 효율성 증가(매번 새로 연결할 필요가 없음)

### **Message 구조**

- **HTTP 요청 메시지**
    - 요청 라인(첫 줄) - method 필드, URL 필드, HTTP 버전 필드
    - 헤더 라인
        
        ![Untitled 5](https://github.com/SSAFY-CSStudy/Network/assets/101400650/2b236a91-e8c5-475d-bf4f-16e6ec7acb87)

- **HTTP 응답 메시지**
    - 상태 라인
        - HTTP 버전 필드
        - **상태 코드**
            - 200 성공
            - 3xx 리다이렉션
            - 4xx 클라이언트 오류
            - 5xx 서버 오류
        - 해당 상태 메시지
    - 헤더 라인
    - 개체 몸체(entity body)
      
        ![Untitled 6](https://github.com/SSAFY-CSStudy/Network/assets/101400650/2070ad4a-9928-4286-86bc-20bb3ad8f4ec)


## 4. 사용자와 서버 간의 상호 작용 : Cookies


- HTTP 서버는 stateless
- 쿠키 사용
    - 서버가 사용자 접속을 제한하거나
    - 사용자에 따라 콘텐츠를 제공하기 원하므로 사용자 확인 필요 시
- 쿠키 : 서비스 계층에서 state 제공
- 동작 과정 
: 웹 서버 사용자 식별 과정
    1. 웹 서버에는 HTTP 요청 메세지 전달
    2. 웹 서버는 유일한 식별 번호를 만들고 이 식별 번호(ID)로 인덱싱 되는 backend database 안에 entry 생성
    3. HTTP 응답 메시지에 `set-cookie : 식별 번호` 의 헤더를 포함해서 전달 
    4. 브라우저는 헤더를 보고, 관리하는 특정한 쿠키 파일에 그 라인을 덧붙인다.
    5. 다시 동일 웹 서버에 요청을 보낼 때
        
        → 브라우저는 쿠키 파일을 참조하고 이 사이트에 대한 식별 번호를 발췌하여 `cookie : 식별 번호` 의 헤더를 요청과 함께 전송 
        
    ![Untitled 7](https://github.com/SSAFY-CSStudy/Network/assets/101400650/b13a8bef-eff8-40ae-b7f5-a2bd5dc0bf41)


## 5. 웹 캐싱

- **웹 캐시(cache)(proxy server)** : 웹 서버(origin server) 를 대신하여 client HTTP 요구를 충족시키는 개체
- **웹 캐시** : 요청과 응답을 모두 하는 client,  server
    - 자체의 저장 디스크 존재
    → 최근 호출된 객체의 사본을 저장 및 보존
    - server : client의 요청을 받음, 응답 보냄
    - client : origin server에 요청을 보냄
    - 일반적으로 ISP(university, company …)가 구입하고 설치

### **프록시 서버의 동작 과정**

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다
2. 웹 캐시는 객체의 사본이 저장되어 있는지 확인
    1. 저장 되어 있다면 : client browser로 HTTP 응답 메세지와 함께 객체를 전송
    2. 갖고 있지 않다면 : 기점 서버로 TCP 연결 설정
3. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메세지를 보낸다. (이때, 이미 설정된 TCP를 통해 보낸다)

### **웹 캐싱 사용 이유**

1. client request에 대한 response time을 줄일 수 있음
: 보통 client와 cache 사이에 높은 속도의 연결이 설정되어 있어 웹 서버 캐시에 객체를 갖고 있다면 병목 현상을 줄일 수 있음
2. 웹 캐시는 한 기관에서 인터넷으로 접속하는 링크 상의 웹 트래픽을 대폭 줄일 수 있음
3. 인터넷 전체의 웹 트래픽을 실질적으로 줄여주어 모든 애플리케이션의 성능이 좋아짐

**웹 캐시 미사용과 사용 성능 비교**

- 평균 객체의 크기가 1Mb 이고, 기관 브라우저로 부터 기점 서버에 대한 평균 요청 비율이 초당 15 요청 이라고 가정
- HTTP 메시지 요청이 무시할만큼 작으므로 네트워크 접속 회선에 어떤 트래픽도 발생시키지 않는다고 가정
- 또한, 접속 회선의 인터넷 부분 라우터가 **HTTP 요청을 전달하고 응답을 받을 때까지 평균 소요 시간**을 2초라 가정
→ `인터넷 지연`

![Untitled 8](https://github.com/SSAFY-CSStudy/Network/assets/101400650/e04b88a5-55c8-4b74-b1b7-81ba29893368)

`총 응답 시간 = LAN 지연 + 접속 지연 + 인터넷 지연` 

LAN의 트래픽 강도 

`(15 요청/초) x (1 Mb/요청) / 100 Mbps = 0.15`

접속 회선(라우터와 라우터 사이)의 트래픽 강도

`(15 요청/초) X (1 Mb/요청) / 15 Mbps = 1`

## 6. 인터넷 전자 메일

![Untitled 9](https://github.com/SSAFY-CSStudy/Network/assets/101400650/a0ccd054-21f3-4515-9cd4-d89face8784e)

인터넷 메일 시스템의 상위 레벨 개념

### **Electronic mail**

**User Agents**, 사용자 에이전트

- mail reader
- 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해줌
- ex) ms outlook, apple mail

**Mail servers**, 메일 서버

- 전자 메일 인프라스트럭처의 중심
- 각 수신자는 메일 서버에 mailbox 보유
    - mailbox : 수신자의 메시지를 유지하고 관리
    - message queue : 보낼 메일 메세지 보냄
    - 일반 메시지는 송신자의 사용자 에이전트에서 전달이 시작되고, 송신자의 메일 서버를 거친 후에 수신자의 메일 서버로 전달된다.
    - 전자메일 박스에 있는 메시지를 보려면 메일 서버는 사용자 계정과 비밀 번호를 이용하여  이용자를 인증해야한다.
- 송신자는 메일 서버의 고장에도 대처해야 한다

**SMTP (Simple Mail Transfer Protocol)**
: 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜

- SMTP는 메일을 송신자의 메일 서버로부터 수신자의 메일 서버로 전송→ `TCP의 신뢰적인 데이터 전송 서비스` 이용
- Client와 Server를 갖고 있다
    - Client와 Server 모두가 모든 메일 서버에서 수행
    - 상대 메일로 송신할 때는 client가 되고 수신할 때는 서버가 됨
- client → server로 이메일 보낼 때 : TCP 이용, port 25
- direct transfer : 보내는 서버 → 받는 서버
- SMTP에서는 모든 메일 메시지의 몸체는 단순한 `7-bit ASCII` 
→ 전송 용량이 제한되어 커다란 첨부 파일이나 비디오 파일을 보낼 때 문제
- 전송의 3과정
    1. handshaking (greeting)
    2. transfer of messages (data exchange)
    3. closure
- alice → bob 에게 메시지 보내는 과정
    
    ![Untitled 10](https://github.com/SSAFY-CSStudy/Network/assets/101400650/3fd38055-60ca-4f0d-8e46-9230862ea16b)

    1. 앨리스는 `전자 메일 사용자 에이전트`를 수행하고, 밥의 전자 메일 주소를 제공하여 메시지를 보내라고 명령한다.
    2. 앨리스의 사용자 에이전트는 메시지를 그녀의 `메일 서버`에게 보내고, 그곳에서 메시지는 `메시지 큐`에 놓인다.
    3. 앨리스의 메일 서버에서 동작하는 SMTP의 클라이언트 측은 메시지 큐에 있는 메시지를 본다.
        
        **밥의 메일 서버에서 수행되고 있는 SMTP 서버에게 `TCP 연결`을 설정
        →** `애플리케이션 핸드 세이킹` 수행
        
    4. 초기 SMTP 핸드셰이킹 이후에 SMTP 클라이언트는 앨리스의 메시지를 TCP 연결로 보낸다. 
    → 25번 포트, TCP 연결, TCP 신뢰적인 데이터 전송 서비스
    5. 밥의 메일 서버 호스트에서 SMTP의 서버 측은 메시지를 수신한다. 밥의 `메일 서버`는 그 메시지를 밥의 `메일 박스`에 놓는다.
    6. 밥은 편한 시간에 그 메시지를 읽기 위해 `사용자 에이전트`를 시동한다.
- conclusion
    - SMTP는 중간 메일 서버 이용 안함
        
        → 메시지를 보낼 때 보내는 데 실패하더라도 중간 메일 서버에 저장되는 것이 아니라 **송신자(보내는 사람)의 메일 서버에** 남아있다
        
- client → server 사이에 메시지 전달 과
    ![Untitled 11](https://github.com/SSAFY-CSStudy/Network/assets/101400650/2064d165-cf5d-4d03-99c6-e67d961ebe47)
